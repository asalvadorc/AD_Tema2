{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Acc\u00e9s a Dades","title":"Acc\u00e9s a Dades"},{"location":"#acces-a-dades","text":"","title":"Acc\u00e9s a Dades"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/1__magatzems_i_fluxos_de_dades/","text":"1 - Magatzems i fluxos de dades En la major part de programes necessitem guardar informaci\u00f3 de forma permanent, de manera que perduren, encara que finalitze l'execuci\u00f3 del programa, o que servesquen de dades inicials. Els fitxers ens proporcionen la forma m\u00e9s senzilla de guardar informaci\u00f3. En el tema anterior vam veure com poder accedir tant a un directori com a un fitxer, per\u00f2 no vam accedir al contingut d'aquestos. Dels fitxers nom\u00e9s pod\u00edem veure les seues caracter\u00edstiques externes: nom, tipus, permisos, grand\u00e0ria, ... Per\u00f2 en cap moment vam accedir al seu contingut. Ser\u00e0 el que veurem en aquest tema. En un fitxer, com d\u00e8iem, quedar\u00e0 guardada la informaci\u00f3 de forma permanent. Ser\u00e0 una seq\u00fc\u00e8ncia de bits , un darrere de l'altre que representaran les dades guardades, b\u00e9 siguen car\u00e0cters d'un text, dades num\u00e9riques, o els bytes d'una imatge, per exemple. Aquesta seq\u00fc\u00e8ncia de bits ens aporta una visi\u00f3 est\u00e0tica de les dades, ja que queden guardades al llarg del temps. Posant un exemple cl\u00e0ssic, els pantans i dip\u00f2sits on s'emmagatzema l'aigua serien comparables als fitxers. Per\u00f2 per a nosaltres aquestos pantans i dip\u00f2sits queden lluny. I quan parlem d'aigua corrent tenim m\u00e9s tend\u00e8ncia a pensar en les canonades i aixetes que ens porten aquesta aigua emmagatzemada fins a nosaltres. Doncs de forma similar, des del punt de vista de l\u2019aplicaci\u00f3, el que realment cobra import\u00e0ncia \u00e9s la transfer\u00e8ncia de dades, m\u00e9s que el magatzem, que arriben aquestes dades a l'aplicaci\u00f3 o que l'aplicaci\u00f3 les puga transferir fins al fitxer. L\u2019eina que ens permet controlar aquestes transfer\u00e8ncies, de forma similar a les aixetes i canonades, l\u2019anomenem flux de dades . \u00c9s un concepte associat a la transmissi\u00f3 seq\u00fcencial d\u2019una s\u00e8rie de dades des de l\u2019aplicaci\u00f3 al dispositiu d\u2019emmagatzematge o a l\u2019inrev\u00e9s. Ens d\u00f3na una visi\u00f3 eminentment din\u00e0mica de la informaci\u00f3. Java utilitza els streams (fluxos de dades) per a poder accedir a la informaci\u00f3. Per\u00f2 els streams no limiten la transfer\u00e8ncia de dades d'un fitxer, sin\u00f3 que es generalitza per a qualsevol font de dades: mem\u00f2ria, xarxa, fins i tot altres aplicacions. D'aquesta manera es generalitza l'acc\u00e9s a la informaci\u00f3 des de qualsevol proced\u00e8ncia: si connectem un stream a un fitxer, estarem accedint a un fitxer, per\u00f2 si connectem el stream a un altre programa estarem accedint a les dades proporcionades per un altre programa. Intentarem veure exemples d'acc\u00e9s a diferents fonts a trav\u00e9s d'un stream, per\u00f2 ho aplicarem sobretot a l'acc\u00e9s a fitxers, clar. Fluxos d'entrada i d'eixida La primera diferenciaci\u00f3 que farem en els fluxos de dades \u00e9s si s\u00f3n d'entrada o d'eixida: Fluxos d'entrada s\u00f3n aquells que serviran per introduir dades des de l'exterior al programa, \u00e9s a dir a la zona de mem\u00f2ria controlada pel programa (variables, ...) Fluxos d'eixida s\u00f3n aquells que serviran per a guardar les dades des de les variables del programa fins a l'exterior, per exemple un fitxer, per a que es guarden de forma permanent. Fluxos i tipus de dades Per mig del stream aconseguirem que una dada es guarde en un fitxer, o millor dit una s\u00e8rie de dades. Quan guardem moltes dades, es compactaran unes al costat de les altres (el que hav\u00edem comentat com a seq\u00fcenciaci\u00f3 de bits). Si intentem recuperar-les, haurem d'anar amb molt de compte amb la grand\u00e0ria de cadascuna de les dades i el seu tipus. Anem a posar un exemple: Suposem que volem guardar una dada num\u00e8rica en un enter ( int ). Els enters, en Java, es guarden en 32 bits. Si volem guardar el n\u00famero 1.213.156.417 , ens quedar\u00e0 en binari (els hem posat en grups de 8 bits, per facilitar la lectura): 01001000 01001111 01001100 01000001 Suposem ara que volem guardar dos n\u00fameros enters, per\u00f2 del tipus short , que nom\u00e9s ocupa 16 bits. El n\u00famero 18.511 es representa en binari com 01001000 01001111, i el n\u00famero 19.521 es representa 01001100 01000001. Si posem una dada darrere de l'altra (com es guardar\u00e0 en un fitxer), el resultat ser\u00e0: 01001000 01001111 01001100 01000001 Suposem ara que volem guardar la paraula HOLA. Si guardem el codi ASCII de cada lletra tindrem: H (01001000), O (01001111), L (01001100) i A (01000001) 01001000 01001111 01001100 01000001 En resum, les 3 informacions (el n\u00famero de 32 bits, els 2 n\u00fameros de 16 bits, i la paraula HOLA) es guarden de forma id\u00e8ntica, com a seq\u00fc\u00e8ncia de bits. Per tant, l'\u00fanica manera de poder recuperar la informaci\u00f3 \u00e9s saber de quin tipus \u00e9s i la mida, a banda de l'ordre com est\u00e0 guardada, clar. Els fluxos de dades de Java transfereixen les dades de manera transparent al programador. No cal indicar la quantitat de bits que cal transferir, sin\u00f3 que es dedueix a partir del tipus de dada que la variable representa. Per\u00f2 sempre haurem de tenir present el tipus de dades i l'ordre. Hi ha, per\u00f2, una excepci\u00f3 amb el tipus char . La multitud d\u2019est\u00e0ndards de codificaci\u00f3 de car\u00e0cters existents en l\u2019actualitat i la diversitat de formats utilitzats a l\u2019hora d\u2019implementar les codificacions, usant segons el cas 8, 16, 32 bits o fins i tot una longitud variable en funci\u00f3 del car\u00e0cter a representar, fan que siga molt dif\u00edcil tractar aquest tipus de dades com una simple seq\u00fc\u00e8ncia de bytes. Internament, Java representa el tipus car\u00e0cter amb una codificaci\u00f3 UNICODE de 16 bits (UTF-16) per tal de suportar m\u00faltiples alfabets a banda de l\u2019occidental. Tot i aix\u00ed, \u00e9s capa\u00e7 de gestionar fonts de dades (fitxers entre d\u2019altres) de diverses codificacions (ASCII, ISO-8859, UTF-8, UTF-16\u2026). En funci\u00f3 de la codificaci\u00f3 triada, el n\u00famero de bits utilitzats en l\u2019emmagatzematge variar\u00e0. Es fa necessari, doncs, un tractament especial a l\u2019hora de manipular aquestes dades. Com veurem, Java disposa d\u2019una jerarquia espec\u00edfica de classes orientades a fluxos de car\u00e0cters per tal de fer aquestos canvis i transformacions totalment transparents al programador. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1 - Magatzems i fluxos de dades"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/1__magatzems_i_fluxos_de_dades/#1-magatzems-i-fluxos-de-dades","text":"En la major part de programes necessitem guardar informaci\u00f3 de forma permanent, de manera que perduren, encara que finalitze l'execuci\u00f3 del programa, o que servesquen de dades inicials. Els fitxers ens proporcionen la forma m\u00e9s senzilla de guardar informaci\u00f3. En el tema anterior vam veure com poder accedir tant a un directori com a un fitxer, per\u00f2 no vam accedir al contingut d'aquestos. Dels fitxers nom\u00e9s pod\u00edem veure les seues caracter\u00edstiques externes: nom, tipus, permisos, grand\u00e0ria, ... Per\u00f2 en cap moment vam accedir al seu contingut. Ser\u00e0 el que veurem en aquest tema. En un fitxer, com d\u00e8iem, quedar\u00e0 guardada la informaci\u00f3 de forma permanent. Ser\u00e0 una seq\u00fc\u00e8ncia de bits , un darrere de l'altre que representaran les dades guardades, b\u00e9 siguen car\u00e0cters d'un text, dades num\u00e9riques, o els bytes d'una imatge, per exemple. Aquesta seq\u00fc\u00e8ncia de bits ens aporta una visi\u00f3 est\u00e0tica de les dades, ja que queden guardades al llarg del temps. Posant un exemple cl\u00e0ssic, els pantans i dip\u00f2sits on s'emmagatzema l'aigua serien comparables als fitxers. Per\u00f2 per a nosaltres aquestos pantans i dip\u00f2sits queden lluny. I quan parlem d'aigua corrent tenim m\u00e9s tend\u00e8ncia a pensar en les canonades i aixetes que ens porten aquesta aigua emmagatzemada fins a nosaltres. Doncs de forma similar, des del punt de vista de l\u2019aplicaci\u00f3, el que realment cobra import\u00e0ncia \u00e9s la transfer\u00e8ncia de dades, m\u00e9s que el magatzem, que arriben aquestes dades a l'aplicaci\u00f3 o que l'aplicaci\u00f3 les puga transferir fins al fitxer. L\u2019eina que ens permet controlar aquestes transfer\u00e8ncies, de forma similar a les aixetes i canonades, l\u2019anomenem flux de dades . \u00c9s un concepte associat a la transmissi\u00f3 seq\u00fcencial d\u2019una s\u00e8rie de dades des de l\u2019aplicaci\u00f3 al dispositiu d\u2019emmagatzematge o a l\u2019inrev\u00e9s. Ens d\u00f3na una visi\u00f3 eminentment din\u00e0mica de la informaci\u00f3. Java utilitza els streams (fluxos de dades) per a poder accedir a la informaci\u00f3. Per\u00f2 els streams no limiten la transfer\u00e8ncia de dades d'un fitxer, sin\u00f3 que es generalitza per a qualsevol font de dades: mem\u00f2ria, xarxa, fins i tot altres aplicacions. D'aquesta manera es generalitza l'acc\u00e9s a la informaci\u00f3 des de qualsevol proced\u00e8ncia: si connectem un stream a un fitxer, estarem accedint a un fitxer, per\u00f2 si connectem el stream a un altre programa estarem accedint a les dades proporcionades per un altre programa. Intentarem veure exemples d'acc\u00e9s a diferents fonts a trav\u00e9s d'un stream, per\u00f2 ho aplicarem sobretot a l'acc\u00e9s a fitxers, clar. Fluxos d'entrada i d'eixida La primera diferenciaci\u00f3 que farem en els fluxos de dades \u00e9s si s\u00f3n d'entrada o d'eixida: Fluxos d'entrada s\u00f3n aquells que serviran per introduir dades des de l'exterior al programa, \u00e9s a dir a la zona de mem\u00f2ria controlada pel programa (variables, ...) Fluxos d'eixida s\u00f3n aquells que serviran per a guardar les dades des de les variables del programa fins a l'exterior, per exemple un fitxer, per a que es guarden de forma permanent. Fluxos i tipus de dades Per mig del stream aconseguirem que una dada es guarde en un fitxer, o millor dit una s\u00e8rie de dades. Quan guardem moltes dades, es compactaran unes al costat de les altres (el que hav\u00edem comentat com a seq\u00fcenciaci\u00f3 de bits). Si intentem recuperar-les, haurem d'anar amb molt de compte amb la grand\u00e0ria de cadascuna de les dades i el seu tipus. Anem a posar un exemple: Suposem que volem guardar una dada num\u00e8rica en un enter ( int ). Els enters, en Java, es guarden en 32 bits. Si volem guardar el n\u00famero 1.213.156.417 , ens quedar\u00e0 en binari (els hem posat en grups de 8 bits, per facilitar la lectura): 01001000 01001111 01001100 01000001 Suposem ara que volem guardar dos n\u00fameros enters, per\u00f2 del tipus short , que nom\u00e9s ocupa 16 bits. El n\u00famero 18.511 es representa en binari com 01001000 01001111, i el n\u00famero 19.521 es representa 01001100 01000001. Si posem una dada darrere de l'altra (com es guardar\u00e0 en un fitxer), el resultat ser\u00e0: 01001000 01001111 01001100 01000001 Suposem ara que volem guardar la paraula HOLA. Si guardem el codi ASCII de cada lletra tindrem: H (01001000), O (01001111), L (01001100) i A (01000001) 01001000 01001111 01001100 01000001 En resum, les 3 informacions (el n\u00famero de 32 bits, els 2 n\u00fameros de 16 bits, i la paraula HOLA) es guarden de forma id\u00e8ntica, com a seq\u00fc\u00e8ncia de bits. Per tant, l'\u00fanica manera de poder recuperar la informaci\u00f3 \u00e9s saber de quin tipus \u00e9s i la mida, a banda de l'ordre com est\u00e0 guardada, clar. Els fluxos de dades de Java transfereixen les dades de manera transparent al programador. No cal indicar la quantitat de bits que cal transferir, sin\u00f3 que es dedueix a partir del tipus de dada que la variable representa. Per\u00f2 sempre haurem de tenir present el tipus de dades i l'ordre. Hi ha, per\u00f2, una excepci\u00f3 amb el tipus char . La multitud d\u2019est\u00e0ndards de codificaci\u00f3 de car\u00e0cters existents en l\u2019actualitat i la diversitat de formats utilitzats a l\u2019hora d\u2019implementar les codificacions, usant segons el cas 8, 16, 32 bits o fins i tot una longitud variable en funci\u00f3 del car\u00e0cter a representar, fan que siga molt dif\u00edcil tractar aquest tipus de dades com una simple seq\u00fc\u00e8ncia de bytes. Internament, Java representa el tipus car\u00e0cter amb una codificaci\u00f3 UNICODE de 16 bits (UTF-16) per tal de suportar m\u00faltiples alfabets a banda de l\u2019occidental. Tot i aix\u00ed, \u00e9s capa\u00e7 de gestionar fonts de dades (fitxers entre d\u2019altres) de diverses codificacions (ASCII, ISO-8859, UTF-8, UTF-16\u2026). En funci\u00f3 de la codificaci\u00f3 triada, el n\u00famero de bits utilitzats en l\u2019emmagatzematge variar\u00e0. Es fa necessari, doncs, un tractament especial a l\u2019hora de manipular aquestes dades. Com veurem, Java disposa d\u2019una jerarquia espec\u00edfica de classes orientades a fluxos de car\u00e0cters per tal de fer aquestos canvis i transformacions totalment transparents al programador. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1 - Magatzems i fluxos de dades"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/211__mtodes_del_inputstream/","text":"2.1.1 - M\u00e8todes del InputStream Nota Per a fer els primers exemples, i \u00fanicament per comoditat, utilitzarem fitxers de text, encara que estiguem en fluxos orientats a byte. A\u00e7\u00f2 no \u00e9s l'adequat, ja que per a fitxers de text haur\u00edem d'utilitzar fluxos orientats a car\u00e0cter. Per\u00f2 com dic \u00e9s per comoditat, perqu\u00e8 ser\u00e0 molt f\u00e0cil crear fitxers des de qualsevol editor de textos, i que despr\u00e9s utilitzarem des de Java o Kotlin. L'inconvenient ser\u00e0 que no tots els car\u00e0cters eixiran de forma correcta, justament per utilitzar els fluxos de dades orientats a byte. El primer m\u00e8tode que hem de veure del InputStream \u00e9s aquell que ens permet una lectura senzilla: int read() : llig el seg\u00fcent byte del flux d'entrada i el retorna com un enter . Si no hi ha cap byte disponible perqu\u00e8 s\u2019ha arribat al final de la seq\u00fc\u00e8ncia de bytes, es retornar\u00e0 -1. Si no es pot llegir el seg\u00fcent byte per alguna causa (per exemple si despr\u00e9s d'arribar al final intentem llegir un altre byte, o perqu\u00e8 es produeix un error en llegir l'entrada) es llan\u00e7ar\u00e0 una excepci\u00f3 del tipus IOException . Es tracta d\u2019un m\u00e8tode abstracte, que les classes especifiques sobreescriuran adaptant-lo a una font de dades concreta (un fitxer, un array de bytes, ...). I observeu com es tracta d'una lectura seq\u00fcencial. Comencem pel primer byte del fitxer, i a cada read llig el seg\u00fcent byte fins arribar al final. Els tractaments que veurem en aquest tema seran sempre seq\u00fcencials. Abans de veure altres m\u00e8todes, mirem un exemple. Per a aquest exemple fa falta un fitxer anomenat f1.txt , que pot ser un fitxer de text creat amb qualsevol editor senzillet, com per exemple gedit o el Bloc de notes . Ha d'estar en el directori del projecte (el projecte Tema2 ), i aix\u00ed no caldr\u00e0 posar la ruta. Per exemple podr\u00edem posar el seg\u00fcent contingut: Hola, qu\u00e8 tal? El que far\u00e0 el programa \u00e9s traure per pantalla car\u00e0cter a car\u00e0cter (en l\u00ednies diferents). L'heu de copiar en un fitxer anomenat Exemple_2_01.kt dins d'un paquet anomenat exemples en el projecte del Tema 2: package exemples import java.io.FileInputStream fun main(args: Array<String>){ val f_in = FileInputStream(\"f1.txt\") var c = f_in.read() while (c!=-1){ println(c.toChar()) c = f_in.read() } f_in.close() } El resultat en Ubuntu ser\u00e0 aquest: H o l a , q u \u00c3 \u00a8 t a l ? Potser en Windows si que apareguen b\u00e9 tots els car\u00e0cters, ja que utilitza per defecte una altra codificaci\u00f3. Per\u00f2 no li donarem ara import\u00e0ncia al fet que no apareguen b\u00e9 els car\u00e0cters especials. Observeu com estem utilitzant un InputStream , concretament un FileInputStream , per a llegir un fitxer de text. A\u00e7\u00f2 no \u00e9s el m\u00e9s apropiat, com ja hav\u00edem comentat abans, sin\u00f3 que haur\u00edem d'utilitzar algun flux orientat a car\u00e0cters, i no orientat a bytes. El programa funcionar\u00e0 si utilitzem codificaci\u00f3 ASCII (o ISO-8859) ja que cada car\u00e0cter es guarda en un byte. Si ens despistem i el fitxer el gaurdem en UTF-8, no eixiran b\u00e9 els car\u00e0cters com \u00e7, \u00f1 o vocals accentuades (que es guarden en 2 bytes). I si el guardem en UTF-16, encara eixir\u00e0 pitjor. Hem utilitzat el constructor que accepta un String com a par\u00e0metre. Queda m\u00e9s curt, per\u00f2 seria totalment equivalent substituir la construcci\u00f3 anterior per aquestes dues l\u00ednies val f = File(\"f1.txt\") val f_in = FileInputStream(f) El read obt\u00e9 un enter, que despr\u00e9s l'intentem convertir en car\u00e0cter. Finalitzem quan l'enter \u00e9s -1. Aquest segon exemple t\u00e9 l'entrada no des d'un fitxer, sin\u00f3 des d'un ByteArrayInputStream . A banda de que l'hem d'inicialitzar diferent, podem observar com el tractament posterior \u00e9s id\u00e8ntic. Copieu-lo en un fitxer anomenat Exemple_2_02.kt : package exemples import java.io.ByteArrayInputStream fun main(args: Array<String>) { val ent_1 = \"Aquest \u00e9s un byte array\" val f_in = ByteArrayInputStream(ent_1.toByteArray()) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Una altra vegada els car\u00e0cters especial eixiran malament, ja que en compte de un InputStream (en aquest cas ByteArrayInputStream ) el m\u00e9s adequat seria un flux orientat a car\u00e0cters, per\u00f2 com a exemple s\u00ed que ens val. Mirem un tercer exemple, per veure el SequenceInputStream , on es poden enganxar de forma sequencial diferents InputStream. Despr\u00e9s d'aquest exemple ja ens centrarem en els fitxers, que \u00e9s el que ens interessa. Copieu-lo en un fitxer anomenat Exemple_2_03.kt : package exemples import java.io.ByteArrayInputStream import java.io.FileInputStream import java.io.SequenceInputStream fun main(args: Array<String>) { val f1 = FileInputStream(\"f1.txt\") val ent_1 = \"Aquest \u00e9s un byte array\" val f2 = ByteArrayInputStream(ent_1.toByteArray()) val f_in = SequenceInputStream(f1,f2) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Altres m\u00e8todes del InputStream s\u00f3n: int read( buffer : ByteArray) : llig un n\u00famero determinat de bytes de l'entrada, guardant-los en el par\u00e0metre (que actuar\u00e0 com un buffer). El n\u00famero de bytes llegits ser\u00e0 com a m\u00e0xim la grand\u00e0ria del buffer, encara que podria ser menor (si no hi ha prou bytes, per exemple). El m\u00e8tode tornar\u00e0 el n\u00famero de bytes que realment s'han llegit com un enter. Si no hi haguera cap byte disponible, es retornar\u00e0 -1. int available() : indica quants bytes hi ha disponibles per a la lectura. Sobretot serviria com a condici\u00f3 de final de bucle (si hi ha 0 bytes disponibles, \u00e9s que ja hem acabat), encara que hi ha altres maneres de fer la condici\u00f3 de final de bucle. long skip( despl : Long) : salta, despreciant-los, tant bytes com indica el par\u00e0metre. Podria ser que no puguera saltar el n\u00famero de bytes especificat per diferents raons. Torna el n\u00famero de bytes realment saltats. int close() : tanca el flux de dades. Mirem un altre exemple, utilitzant ara el buffer com a par\u00e0metre del read . Fa falta que existesca un fitxer anomenat f2.txt en l'arrel del projecte, com es comenta despr\u00e9s. Copieu-lo en un fitxer anomenat Exemple_2_04.kt : package exemples import java.io.FileInputStream fun main(args: Array<String>) { val f_in = FileInputStream(\"f2.txt\") var buffer = ByteArray(30) var n = f_in.read(buffer) while (n != -1) { for (i in 0..n - 1) print(buffer[i].toChar()) println(\"\") n = f_in.read(buffer) } f_in.close(); } Es llegiran els car\u00e0cters de 30 en 30, ja que el buffer \u00e9s d'aquesta grand\u00e0ria. Com que es guarda en un buffer de bytes (bytes, no car\u00e0cters), haurem de rec\u00f3rrer aquest buffer (fins el n\u00famero de car\u00e0cters llegits, que \u00e9s n ) convertint cada byte en car\u00e0cter. Hem suposat que en el fitxer f2.txt tenim un text prou llarg com per a veure el funcionament. Si per exemple el contingut de f2.txt \u00e9s aquest: Hola. Aquest \u00e9s un text m\u00e9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cters especials potser no isquen b\u00e9. Aquesta seria l'eixida: Hola. Aquest \uffc3\uffa9s un text m\uffc3\uffa9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\uffc3\uffa0cters. Com que ho llegim des d'un InputStream, els car\uffc3 \uffa0cters especials potser no isq uen b\uffc3\uffa9. Recordeu que estem llegint un fitxer de text des d'un InputStream, cosa gens convenient ja que els car\u00e0cters com \u00e7, \u00f1, o vocals accentuades dif\u00edcilment podrem fer que apareguen b\u00e9. Ho arreglarem amb els fluxos orientats a car\u00e0cter. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.1.1 - M\u00e8todes del InputStream"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/211__mtodes_del_inputstream/#211-metodes-del-inputstream","text":"Nota Per a fer els primers exemples, i \u00fanicament per comoditat, utilitzarem fitxers de text, encara que estiguem en fluxos orientats a byte. A\u00e7\u00f2 no \u00e9s l'adequat, ja que per a fitxers de text haur\u00edem d'utilitzar fluxos orientats a car\u00e0cter. Per\u00f2 com dic \u00e9s per comoditat, perqu\u00e8 ser\u00e0 molt f\u00e0cil crear fitxers des de qualsevol editor de textos, i que despr\u00e9s utilitzarem des de Java o Kotlin. L'inconvenient ser\u00e0 que no tots els car\u00e0cters eixiran de forma correcta, justament per utilitzar els fluxos de dades orientats a byte. El primer m\u00e8tode que hem de veure del InputStream \u00e9s aquell que ens permet una lectura senzilla: int read() : llig el seg\u00fcent byte del flux d'entrada i el retorna com un enter . Si no hi ha cap byte disponible perqu\u00e8 s\u2019ha arribat al final de la seq\u00fc\u00e8ncia de bytes, es retornar\u00e0 -1. Si no es pot llegir el seg\u00fcent byte per alguna causa (per exemple si despr\u00e9s d'arribar al final intentem llegir un altre byte, o perqu\u00e8 es produeix un error en llegir l'entrada) es llan\u00e7ar\u00e0 una excepci\u00f3 del tipus IOException . Es tracta d\u2019un m\u00e8tode abstracte, que les classes especifiques sobreescriuran adaptant-lo a una font de dades concreta (un fitxer, un array de bytes, ...). I observeu com es tracta d'una lectura seq\u00fcencial. Comencem pel primer byte del fitxer, i a cada read llig el seg\u00fcent byte fins arribar al final. Els tractaments que veurem en aquest tema seran sempre seq\u00fcencials. Abans de veure altres m\u00e8todes, mirem un exemple. Per a aquest exemple fa falta un fitxer anomenat f1.txt , que pot ser un fitxer de text creat amb qualsevol editor senzillet, com per exemple gedit o el Bloc de notes . Ha d'estar en el directori del projecte (el projecte Tema2 ), i aix\u00ed no caldr\u00e0 posar la ruta. Per exemple podr\u00edem posar el seg\u00fcent contingut: Hola, qu\u00e8 tal? El que far\u00e0 el programa \u00e9s traure per pantalla car\u00e0cter a car\u00e0cter (en l\u00ednies diferents). L'heu de copiar en un fitxer anomenat Exemple_2_01.kt dins d'un paquet anomenat exemples en el projecte del Tema 2: package exemples import java.io.FileInputStream fun main(args: Array<String>){ val f_in = FileInputStream(\"f1.txt\") var c = f_in.read() while (c!=-1){ println(c.toChar()) c = f_in.read() } f_in.close() } El resultat en Ubuntu ser\u00e0 aquest: H o l a , q u \u00c3 \u00a8 t a l ? Potser en Windows si que apareguen b\u00e9 tots els car\u00e0cters, ja que utilitza per defecte una altra codificaci\u00f3. Per\u00f2 no li donarem ara import\u00e0ncia al fet que no apareguen b\u00e9 els car\u00e0cters especials. Observeu com estem utilitzant un InputStream , concretament un FileInputStream , per a llegir un fitxer de text. A\u00e7\u00f2 no \u00e9s el m\u00e9s apropiat, com ja hav\u00edem comentat abans, sin\u00f3 que haur\u00edem d'utilitzar algun flux orientat a car\u00e0cters, i no orientat a bytes. El programa funcionar\u00e0 si utilitzem codificaci\u00f3 ASCII (o ISO-8859) ja que cada car\u00e0cter es guarda en un byte. Si ens despistem i el fitxer el gaurdem en UTF-8, no eixiran b\u00e9 els car\u00e0cters com \u00e7, \u00f1 o vocals accentuades (que es guarden en 2 bytes). I si el guardem en UTF-16, encara eixir\u00e0 pitjor. Hem utilitzat el constructor que accepta un String com a par\u00e0metre. Queda m\u00e9s curt, per\u00f2 seria totalment equivalent substituir la construcci\u00f3 anterior per aquestes dues l\u00ednies val f = File(\"f1.txt\") val f_in = FileInputStream(f) El read obt\u00e9 un enter, que despr\u00e9s l'intentem convertir en car\u00e0cter. Finalitzem quan l'enter \u00e9s -1. Aquest segon exemple t\u00e9 l'entrada no des d'un fitxer, sin\u00f3 des d'un ByteArrayInputStream . A banda de que l'hem d'inicialitzar diferent, podem observar com el tractament posterior \u00e9s id\u00e8ntic. Copieu-lo en un fitxer anomenat Exemple_2_02.kt : package exemples import java.io.ByteArrayInputStream fun main(args: Array<String>) { val ent_1 = \"Aquest \u00e9s un byte array\" val f_in = ByteArrayInputStream(ent_1.toByteArray()) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Una altra vegada els car\u00e0cters especial eixiran malament, ja que en compte de un InputStream (en aquest cas ByteArrayInputStream ) el m\u00e9s adequat seria un flux orientat a car\u00e0cters, per\u00f2 com a exemple s\u00ed que ens val. Mirem un tercer exemple, per veure el SequenceInputStream , on es poden enganxar de forma sequencial diferents InputStream. Despr\u00e9s d'aquest exemple ja ens centrarem en els fitxers, que \u00e9s el que ens interessa. Copieu-lo en un fitxer anomenat Exemple_2_03.kt : package exemples import java.io.ByteArrayInputStream import java.io.FileInputStream import java.io.SequenceInputStream fun main(args: Array<String>) { val f1 = FileInputStream(\"f1.txt\") val ent_1 = \"Aquest \u00e9s un byte array\" val f2 = ByteArrayInputStream(ent_1.toByteArray()) val f_in = SequenceInputStream(f1,f2) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Altres m\u00e8todes del InputStream s\u00f3n: int read( buffer : ByteArray) : llig un n\u00famero determinat de bytes de l'entrada, guardant-los en el par\u00e0metre (que actuar\u00e0 com un buffer). El n\u00famero de bytes llegits ser\u00e0 com a m\u00e0xim la grand\u00e0ria del buffer, encara que podria ser menor (si no hi ha prou bytes, per exemple). El m\u00e8tode tornar\u00e0 el n\u00famero de bytes que realment s'han llegit com un enter. Si no hi haguera cap byte disponible, es retornar\u00e0 -1. int available() : indica quants bytes hi ha disponibles per a la lectura. Sobretot serviria com a condici\u00f3 de final de bucle (si hi ha 0 bytes disponibles, \u00e9s que ja hem acabat), encara que hi ha altres maneres de fer la condici\u00f3 de final de bucle. long skip( despl : Long) : salta, despreciant-los, tant bytes com indica el par\u00e0metre. Podria ser que no puguera saltar el n\u00famero de bytes especificat per diferents raons. Torna el n\u00famero de bytes realment saltats. int close() : tanca el flux de dades. Mirem un altre exemple, utilitzant ara el buffer com a par\u00e0metre del read . Fa falta que existesca un fitxer anomenat f2.txt en l'arrel del projecte, com es comenta despr\u00e9s. Copieu-lo en un fitxer anomenat Exemple_2_04.kt : package exemples import java.io.FileInputStream fun main(args: Array<String>) { val f_in = FileInputStream(\"f2.txt\") var buffer = ByteArray(30) var n = f_in.read(buffer) while (n != -1) { for (i in 0..n - 1) print(buffer[i].toChar()) println(\"\") n = f_in.read(buffer) } f_in.close(); } Es llegiran els car\u00e0cters de 30 en 30, ja que el buffer \u00e9s d'aquesta grand\u00e0ria. Com que es guarda en un buffer de bytes (bytes, no car\u00e0cters), haurem de rec\u00f3rrer aquest buffer (fins el n\u00famero de car\u00e0cters llegits, que \u00e9s n ) convertint cada byte en car\u00e0cter. Hem suposat que en el fitxer f2.txt tenim un text prou llarg com per a veure el funcionament. Si per exemple el contingut de f2.txt \u00e9s aquest: Hola. Aquest \u00e9s un text m\u00e9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cters especials potser no isquen b\u00e9. Aquesta seria l'eixida: Hola. Aquest \uffc3\uffa9s un text m\uffc3\uffa9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\uffc3\uffa0cters. Com que ho llegim des d'un InputStream, els car\uffc3 \uffa0cters especials potser no isq uen b\uffc3\uffa9. Recordeu que estem llegint un fitxer de text des d'un InputStream, cosa gens convenient ja que els car\u00e0cters com \u00e7, \u00f1, o vocals accentuades dif\u00edcilment podrem fer que apareguen b\u00e9. Ho arreglarem amb els fluxos orientats a car\u00e0cter. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.1.1 - M\u00e8todes del InputStream"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/212__mtodes_del_outputstream/","text":"2.1.2 - M\u00e8todes del OutputStream Comencem tamb\u00e9 pel m\u00e9s senzill i primordial, el m\u00e8tode que escriu un byte (recordeu que estem en fluxos orientats a bytes). void write( byte : Int) : escriu el byte passat com a par\u00e0metre en el flux d'eixida. Encara que el par\u00e0metre \u00e9s de tipus int, nom\u00e9s s'escriur\u00e0 un byte. Si no es poguera fer l'escriptura per qualsevol motiu (per exemple, disc ple), es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus IOException . Igual que en l'apartat anterior, anem a veure un exemple senzill d'utilitzaci\u00f3, en qu\u00e8 guardarem en un fitxer el contingut d'una cadena (encara que ja sabem que no \u00e9s el m\u00e9s apropiat utilitzar fluxos orientats a bytes per a informaci\u00f3 de car\u00e0cters). En aquest primer exemple del OutputStream treballarem sobre un fitxer inexistent. Es podr\u00e0 comprovar que el resultat ser\u00e0 la creaci\u00f3 del fitxer amb el contingut. Hem de fer constar que si no es tanca el fitxer (millor dit el flux d'eixida) podria ser que no es guardara res en el fitxer. Per tant tancar \u00e9s una operaci\u00f3 ben important que no hem d'oblidar . Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_11.kt : package exemples import java.io.FileOutputStream fun main(args: Array<String>) { val text = \"Contingut per al fitxer.\" val f_out = FileOutputStream(\"f3.txt\") for (c in text) f_out.write(c.toInt()) f_out.close() } Observeu com hem convertit cada car\u00e0cter a Int per a que puga funcionar, ja que el m\u00e8tode write() accepta un enter. En el constructor del OutputStream no hem indicat el segon par\u00e0metre, aquell que indicava si era per a afegir o no, i per tant si no existia el fitxer el crear\u00e0, per\u00f2 si ja existia el fitxer, destruir\u00e0 el seu contingut i el substituir\u00e0 pel nou contingut. Per aix\u00f2 si tornem a executar el programa, tindrem el mateix resultat. Contingut per al fitxer. La codificaci\u00f3 del fitxer haur\u00e0 segut la que tinga per defecte el Sistema Operatiu, que en el cas d'Ubuntu \u00e9s UTF-8, i en el cas de Windows \u00e9s ISO-8859. Anem a provar a substituir el constructor, posant ara val f_out = FileOutputStream(\"f3.txt\",true) Si l'executem una altra vegada, veurem que afegir\u00e0 al final, sense destruir el que ja hi havia. Contingut per al fitxer.Contingut per al fitxer. Altres m\u00e8todes del OutputStream s\u00f3n: void write( buffer : ByteArray) : escriu el contingut de l'array de bytes al fitxer. Cal que buffer no siga nul, o provocarem un error. void write( buffer : ByteArray, pos : Int, llarg : Int) : escriu al fitxer el contingut de l'array que est\u00e0 a partir de la posici\u00f3 pos i tants bytes com assenyale llarg . void flush() : Guardar les dades en un fitxer \u00e9s una operaci\u00f3 relativament lenta, ja que \u00e9s accedir a un dispositiu lent (millor dit, no tan r\u00e0pid com la mem\u00f2ria). \u00c9s habitual que s'utilitze una mem\u00f2ria interm\u00e8dia per a que les coses no vagen tan lentes (com si f\u00f3ra una cach\u00e9). Per\u00f2 potser que les dades no estiguen guardades encara en el fitxer, sin\u00f3 que encara estiguen en aquesta cach\u00e9. El m\u00e8tode flush obliga a escriure els bytes que queden encara a la cach\u00e9 f\u00edsicament al fitxer d'eixida. void close() : tanca el flux d'eixida, alliberant els recursos. Si quedava alguna cosa en la cach\u00e9, es guardar\u00e0 al fitxer i es tancar\u00e0 el flux. En aquest exemple es copia el contingut del fitxer f2.txt en el fitxer f4.txt , per\u00f2 en compte d'anar byte a byte, anirem de 30 en 30, amb un buffer de 30 posicions. Podr\u00edem cometre l'error de la l\u00ednia 13 del seg\u00fcent programa, la del comentari, d'escriure sempre els 30 car\u00e0cters. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_12.kt : package exemples import java.io.FileInputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f_in = FileInputStream(\"f2.txt\") val f_out = FileOutputStream(\"f4.txt\") var buffer = ByteArray(30) var num = f_in.read(buffer) while (num != -1) { f_out.write(buffer) // a\u00e7\u00f2 \u00e9s un error num = f_in.read(buffer) } f_in.close(); f_out.close(); } D'aquesta manera, l'\u00faltima vegada que \u00e9s llig \u00e9s molt possible que no hi hagen exactament 30 car\u00e0cters. Si hi ha menys de 30 car\u00e0cters, nom\u00e9s es llegiran els que queden al principi del buffer, i en la resta del buffer hi ha la informaci\u00f3 anterior, la de la pen\u00faltima lectura. En definitiva, tenim \"basura\", i si no ho controlem el resultat no ser\u00e0 el correcte. Aquest ser`el contingut de f4.txt : Hola. Aquest \u00e9s un text m\u00e9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cters especials potser no isquen b\u00e9. pecials potser no isq Ha eixit d'aquesta manera perqu\u00e8 l'\u00faltima vegada nom\u00e9s s'han llegit 9 bytes. Els 21 restants tenen la informaci\u00f3 encara de la pen\u00faltima lectura. Per a fer-lo de forma correcta, ens aprofitem de que read(buffer) torna el n\u00famero de bytes realment llegits, per escriure exactament aquest n\u00famero. Per tant substituirem la l\u00ednia 13, la del comentari, per aquesta altra: f_out.write(buffer,0,num) // ara s\u00ed que funcionar\u00e0 b\u00e9 Ara el contingut de f4.txt ser\u00e0 id\u00e8ntic al de f2.txt Nota important Per a assegurar-nos que realment escrivim en el fitxer i no es queda res en la mem\u00f2ria interm\u00e8dia, hem de tancar sempre els fluxos d'eixida . Si ens oblidem de tancar-los, \u00e9s molt f\u00e0cil que no s'acabe d'escriure f\u00edsicament en el fitxer. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.1.2 - M\u00e8todes del OutputStream"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/212__mtodes_del_outputstream/#212-metodes-del-outputstream","text":"Comencem tamb\u00e9 pel m\u00e9s senzill i primordial, el m\u00e8tode que escriu un byte (recordeu que estem en fluxos orientats a bytes). void write( byte : Int) : escriu el byte passat com a par\u00e0metre en el flux d'eixida. Encara que el par\u00e0metre \u00e9s de tipus int, nom\u00e9s s'escriur\u00e0 un byte. Si no es poguera fer l'escriptura per qualsevol motiu (per exemple, disc ple), es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus IOException . Igual que en l'apartat anterior, anem a veure un exemple senzill d'utilitzaci\u00f3, en qu\u00e8 guardarem en un fitxer el contingut d'una cadena (encara que ja sabem que no \u00e9s el m\u00e9s apropiat utilitzar fluxos orientats a bytes per a informaci\u00f3 de car\u00e0cters). En aquest primer exemple del OutputStream treballarem sobre un fitxer inexistent. Es podr\u00e0 comprovar que el resultat ser\u00e0 la creaci\u00f3 del fitxer amb el contingut. Hem de fer constar que si no es tanca el fitxer (millor dit el flux d'eixida) podria ser que no es guardara res en el fitxer. Per tant tancar \u00e9s una operaci\u00f3 ben important que no hem d'oblidar . Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_11.kt : package exemples import java.io.FileOutputStream fun main(args: Array<String>) { val text = \"Contingut per al fitxer.\" val f_out = FileOutputStream(\"f3.txt\") for (c in text) f_out.write(c.toInt()) f_out.close() } Observeu com hem convertit cada car\u00e0cter a Int per a que puga funcionar, ja que el m\u00e8tode write() accepta un enter. En el constructor del OutputStream no hem indicat el segon par\u00e0metre, aquell que indicava si era per a afegir o no, i per tant si no existia el fitxer el crear\u00e0, per\u00f2 si ja existia el fitxer, destruir\u00e0 el seu contingut i el substituir\u00e0 pel nou contingut. Per aix\u00f2 si tornem a executar el programa, tindrem el mateix resultat. Contingut per al fitxer. La codificaci\u00f3 del fitxer haur\u00e0 segut la que tinga per defecte el Sistema Operatiu, que en el cas d'Ubuntu \u00e9s UTF-8, i en el cas de Windows \u00e9s ISO-8859. Anem a provar a substituir el constructor, posant ara val f_out = FileOutputStream(\"f3.txt\",true) Si l'executem una altra vegada, veurem que afegir\u00e0 al final, sense destruir el que ja hi havia. Contingut per al fitxer.Contingut per al fitxer. Altres m\u00e8todes del OutputStream s\u00f3n: void write( buffer : ByteArray) : escriu el contingut de l'array de bytes al fitxer. Cal que buffer no siga nul, o provocarem un error. void write( buffer : ByteArray, pos : Int, llarg : Int) : escriu al fitxer el contingut de l'array que est\u00e0 a partir de la posici\u00f3 pos i tants bytes com assenyale llarg . void flush() : Guardar les dades en un fitxer \u00e9s una operaci\u00f3 relativament lenta, ja que \u00e9s accedir a un dispositiu lent (millor dit, no tan r\u00e0pid com la mem\u00f2ria). \u00c9s habitual que s'utilitze una mem\u00f2ria interm\u00e8dia per a que les coses no vagen tan lentes (com si f\u00f3ra una cach\u00e9). Per\u00f2 potser que les dades no estiguen guardades encara en el fitxer, sin\u00f3 que encara estiguen en aquesta cach\u00e9. El m\u00e8tode flush obliga a escriure els bytes que queden encara a la cach\u00e9 f\u00edsicament al fitxer d'eixida. void close() : tanca el flux d'eixida, alliberant els recursos. Si quedava alguna cosa en la cach\u00e9, es guardar\u00e0 al fitxer i es tancar\u00e0 el flux. En aquest exemple es copia el contingut del fitxer f2.txt en el fitxer f4.txt , per\u00f2 en compte d'anar byte a byte, anirem de 30 en 30, amb un buffer de 30 posicions. Podr\u00edem cometre l'error de la l\u00ednia 13 del seg\u00fcent programa, la del comentari, d'escriure sempre els 30 car\u00e0cters. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_12.kt : package exemples import java.io.FileInputStream import java.io.FileOutputStream fun main(args: Array<String>) { val f_in = FileInputStream(\"f2.txt\") val f_out = FileOutputStream(\"f4.txt\") var buffer = ByteArray(30) var num = f_in.read(buffer) while (num != -1) { f_out.write(buffer) // a\u00e7\u00f2 \u00e9s un error num = f_in.read(buffer) } f_in.close(); f_out.close(); } D'aquesta manera, l'\u00faltima vegada que \u00e9s llig \u00e9s molt possible que no hi hagen exactament 30 car\u00e0cters. Si hi ha menys de 30 car\u00e0cters, nom\u00e9s es llegiran els que queden al principi del buffer, i en la resta del buffer hi ha la informaci\u00f3 anterior, la de la pen\u00faltima lectura. En definitiva, tenim \"basura\", i si no ho controlem el resultat no ser\u00e0 el correcte. Aquest ser`el contingut de f4.txt : Hola. Aquest \u00e9s un text m\u00e9s llarg, per veure com gestiona els bytes amb un buffer de 30 car\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cters especials potser no isquen b\u00e9. pecials potser no isq Ha eixit d'aquesta manera perqu\u00e8 l'\u00faltima vegada nom\u00e9s s'han llegit 9 bytes. Els 21 restants tenen la informaci\u00f3 encara de la pen\u00faltima lectura. Per a fer-lo de forma correcta, ens aprofitem de que read(buffer) torna el n\u00famero de bytes realment llegits, per escriure exactament aquest n\u00famero. Per tant substituirem la l\u00ednia 13, la del comentari, per aquesta altra: f_out.write(buffer,0,num) // ara s\u00ed que funcionar\u00e0 b\u00e9 Ara el contingut de f4.txt ser\u00e0 id\u00e8ntic al de f2.txt Nota important Per a assegurar-nos que realment escrivim en el fitxer i no es queda res en la mem\u00f2ria interm\u00e8dia, hem de tancar sempre els fluxos d'eixida . Si ens oblidem de tancar-los, \u00e9s molt f\u00e0cil que no s'acabe d'escriure f\u00edsicament en el fitxer. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.1.2 - M\u00e8todes del OutputStream"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/21__fluxos_orientats_a_bytes/","text":"2.1 - Fluxos orientats a bytes L'arrel, la base de tota la jerarquia s\u00f3n InputStream i OutputStream , respectivament per a fluxos d'entrada i d'eixida. Comentarem els fluxos d'entrada, i els d'eixida s\u00f3n totalment paral\u00b7lels. La super-classe InputStream servir\u00e0 per a fer l'entrada des de qualsevol dispositiu: fitxer, array de bytes, una tuberia (per a dur dades des d'una altra aplicaci\u00f3)... Totes les classes d'entrada heretaran d'ella, i serviran per especificar exactament d'on (per exemple un fitxer: FileInputStream ) o per a donar alguna altra funcionalitat, com anirem veient a poc a poc. D'aquesta manera, els m\u00e8todes que es defineixen s'hauran d'implementar per les classes que hereten de la super-classe i assegura una uniformitat, siga quina siga la font. Fem una ullada r\u00e0pida a la jerarquia de classes en la seg\u00fcent imatge: De moment mirem \u00fanicament les que estan en color taronja , que especificaran quina ser\u00e0 la font de dades: Classe Explicaci\u00f3 FileInputStream Per a llegir informaci\u00f3 d'un fitxer PipedInputStream Per a llegir des d'una tuberia (\u00e9s a dir informaci\u00f3 que ve d'un altre programa) ByteArrayInputStream L'entrada ser\u00e0 un array de bytes SequenceInputStream Servir\u00e0 per enlla\u00e7ar dues entrades en una de sola, seq\u00fcencialment Evidentment ens centrarem en la primera, que \u00e9s la que m\u00e9s ens interessa per a la perman\u00e8ncia de les dades, per\u00f2 posarem algun exemple de les altres (concretament ByteArrayInputStream ). Els fluxos d'eixida s\u00f3n molt molt pareguts, tots ells heretaran de OutputStream : Classe Explicaci\u00f3 FileOutputStream Per a guardar informaci\u00f3 en un fitxer PipedOutputStream Per a traure cap a una tuberia (\u00e9s a dir informaci\u00f3 que anir\u00e0 a un altre programa) ByteArrayOutputStream L'eixida ser\u00e0 un array de bytes Constructors de FileInputStream Com hem comentat, qui m\u00e9s ens interessa de tots els InputStream \u00e9s el FileInpuStream , per a poder accedir a la informaci\u00f3 d'un fitxer. Dos s\u00f3n els constructors de FileInputStream: FileInputStream ( f : File) : en el par\u00e0metre se li passa un File (dels vistos en el tema anterior), que ha de ser una refer\u00e8ncia al fitxer. FileInputStream ( nom_f : String) : en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Ens permetr\u00e0 fer refer\u00e8ncia al fitxer de forma m\u00e9s r\u00e0pida, sense haver de passar per un File. Constructors del FileOutputStream Canviaran lleugerament respecte als d'entrada, ja que a m\u00e9s de fer refer\u00e8ncia al fitxer, opcionalment podrem d'especificar la manera d'escriure en el fitxer en cas que aquest ja existesca: b\u00e9 afegint al final, o b\u00e9 destruint la informaci\u00f3 anterior. Aquestos s\u00f3n els constructors: FileOutputStream ( f : File) : en el par\u00e0metre se li passa un File. Si no existia, el crear\u00e0; si ja existia esborrar\u00e0 el contingut. En ambd\u00f3s casos l'obrir\u00e0 en mode escriptura. FileOutputStream ( nom_f : String) : igual que en l'anterior, per\u00f2 en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. FileOutputStream ( f : File, afegir : Boolean) : \u00e9s com el primer, per\u00f2 si en el segon par\u00e0metre se li passa true , en cas que ja existira el fitxer, la informaci\u00f3 s'afegir\u00e0 al final, en compte de substituir el que ja hi havia. Si en aquest par\u00e0metre se li passa false s'esborrar\u00e0 el contingut anterior (com en el primer cas). FileOutputStream ( nom_f : String , __ afegir __ : Boolean) : igual que en l'anterior, per\u00f2 en el primer par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.1 - Fluxos orientats a bytes"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/21__fluxos_orientats_a_bytes/#21-fluxos-orientats-a-bytes","text":"L'arrel, la base de tota la jerarquia s\u00f3n InputStream i OutputStream , respectivament per a fluxos d'entrada i d'eixida. Comentarem els fluxos d'entrada, i els d'eixida s\u00f3n totalment paral\u00b7lels. La super-classe InputStream servir\u00e0 per a fer l'entrada des de qualsevol dispositiu: fitxer, array de bytes, una tuberia (per a dur dades des d'una altra aplicaci\u00f3)... Totes les classes d'entrada heretaran d'ella, i serviran per especificar exactament d'on (per exemple un fitxer: FileInputStream ) o per a donar alguna altra funcionalitat, com anirem veient a poc a poc. D'aquesta manera, els m\u00e8todes que es defineixen s'hauran d'implementar per les classes que hereten de la super-classe i assegura una uniformitat, siga quina siga la font. Fem una ullada r\u00e0pida a la jerarquia de classes en la seg\u00fcent imatge: De moment mirem \u00fanicament les que estan en color taronja , que especificaran quina ser\u00e0 la font de dades: Classe Explicaci\u00f3 FileInputStream Per a llegir informaci\u00f3 d'un fitxer PipedInputStream Per a llegir des d'una tuberia (\u00e9s a dir informaci\u00f3 que ve d'un altre programa) ByteArrayInputStream L'entrada ser\u00e0 un array de bytes SequenceInputStream Servir\u00e0 per enlla\u00e7ar dues entrades en una de sola, seq\u00fcencialment Evidentment ens centrarem en la primera, que \u00e9s la que m\u00e9s ens interessa per a la perman\u00e8ncia de les dades, per\u00f2 posarem algun exemple de les altres (concretament ByteArrayInputStream ). Els fluxos d'eixida s\u00f3n molt molt pareguts, tots ells heretaran de OutputStream : Classe Explicaci\u00f3 FileOutputStream Per a guardar informaci\u00f3 en un fitxer PipedOutputStream Per a traure cap a una tuberia (\u00e9s a dir informaci\u00f3 que anir\u00e0 a un altre programa) ByteArrayOutputStream L'eixida ser\u00e0 un array de bytes Constructors de FileInputStream Com hem comentat, qui m\u00e9s ens interessa de tots els InputStream \u00e9s el FileInpuStream , per a poder accedir a la informaci\u00f3 d'un fitxer. Dos s\u00f3n els constructors de FileInputStream: FileInputStream ( f : File) : en el par\u00e0metre se li passa un File (dels vistos en el tema anterior), que ha de ser una refer\u00e8ncia al fitxer. FileInputStream ( nom_f : String) : en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Ens permetr\u00e0 fer refer\u00e8ncia al fitxer de forma m\u00e9s r\u00e0pida, sense haver de passar per un File. Constructors del FileOutputStream Canviaran lleugerament respecte als d'entrada, ja que a m\u00e9s de fer refer\u00e8ncia al fitxer, opcionalment podrem d'especificar la manera d'escriure en el fitxer en cas que aquest ja existesca: b\u00e9 afegint al final, o b\u00e9 destruint la informaci\u00f3 anterior. Aquestos s\u00f3n els constructors: FileOutputStream ( f : File) : en el par\u00e0metre se li passa un File. Si no existia, el crear\u00e0; si ja existia esborrar\u00e0 el contingut. En ambd\u00f3s casos l'obrir\u00e0 en mode escriptura. FileOutputStream ( nom_f : String) : igual que en l'anterior, per\u00f2 en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. FileOutputStream ( f : File, afegir : Boolean) : \u00e9s com el primer, per\u00f2 si en el segon par\u00e0metre se li passa true , en cas que ja existira el fitxer, la informaci\u00f3 s'afegir\u00e0 al final, en compte de substituir el que ja hi havia. Si en aquest par\u00e0metre se li passa false s'esborrar\u00e0 el contingut anterior (com en el primer cas). FileOutputStream ( nom_f : String , __ afegir __ : Boolean) : igual que en l'anterior, per\u00f2 en el primer par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.1 - Fluxos orientats a bytes"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/221__mtodes_del_reader/","text":"2.2.1 - M\u00e8todes del Reader Els m\u00e8todes del Reader s\u00f3n absolutament similars als del InputStream . La difer\u00e8ncia \u00e9s que ara llegir\u00e0 sempre un car\u00e0cter. I no ens haurem de preocupar pel format en qu\u00e8 est\u00e0 guardat, i de i ocupa un o dos bytes. Sempre el llegir\u00e0 b\u00e9, siga quina siga la codificaci\u00f3 utilitzada, com ja hav\u00edem comentat abans: int read() : llig el seg\u00fcent car\u00e0cter del flux d'entrada i el retorna com un enter. Si no hi ha cap car\u00e0cter disponible perqu\u00e8 s\u2019ha assolit el final de la seq\u00fc\u00e8ncia, es retornar\u00e0 -1. Si no es pot llegir el seg\u00fcent car\u00e0cter per alguna causa (per exemple si despr\u00e9s d'arribar al final intentem llegir un altre car\u00e0cter, o perqu\u00e8 es produeix un error en llegir l'entrada) es llan\u00e7ar\u00e0 una excepci\u00f3 del tipus ** IOException **. Es tracta d\u2019un m\u00e8tode abstracte, que les classes especifiques sobreescriuran adaptant-lo a una font de dades concreta (un fitxer, un array de car\u00e0cters, ...). Abans de veure altres m\u00e8todes, mirem un exemple que \u00e9s id\u00e8ntic al primer exemple del InputStream, per\u00f2 canviant FileInputStream per FileReader. Llegir\u00e0 el mateix fitxer anomenat f1.txt , utilitzat en aquell moment, per\u00f2 ara segurament llegir\u00e0 tots els car\u00e0cters b\u00e9. El que far\u00e0 \u00e9s traure per pantalla car\u00e0cter a car\u00e0cter (en l\u00ednies diferents). Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_21.kt : package exemples import java.io.FileReader fun main(args: Array<String>){ val f_in = FileReader(\"f1.txt\") var c = f_in.read() while (c!=-1){ println(c.toChar()) c = f_in.read() } f_in.close() } Ara segurament s\u00ed que haur\u00e0 llegit b\u00e9 tots els car\u00e0cters, incloent \u00f1, \u00e7, vocals accentuades, etc. Si encara tenim el mateix contingut en f1.txt , el resultat ser\u00e0 ara: H o l a , q u \u00e8 t a l ? El m\u00e9s normal \u00e9s que en crear el fitxer f1.txt amb algun editor, el guardem amb la codificaci\u00f3 per defecte, que en cas de Windows \u00e9s ASCII (o ISO-8859) i en el cas de Linux \u00e9s UTF-8. I despr\u00e9s des de Java, el FileReader utilitzar\u00e0 la codificaci\u00f3 per defecte del Sistema Operatiu. \u00c9s a dir que en Linux el fitxer ha d'estar guardat en UTF-8 per a que el puga llegir b\u00e9, i en Windows en ASCII. Mirem tamb\u00e9 l'exemple equivalent al segon. All\u00e0 utilitz\u00e0vem un ByteArrayInputStream com a entrada. Ara podr\u00edem utilitzar un CharArrayReader , per\u00f2 ho farem amb un StringReader , i quedar\u00e0 m\u00e9s curt. A banda de que l'hem d'inicialitzar diferent, podem observar com el tractament posterior \u00e9s id\u00e8ntic. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_22.kt : package exemples import java.io.CharArrayReader fun main(args: Array<String>) { val ent_1 = \"Aquest \u00e9s un byte array\" val f_in = CharArrayReader(ent_1.toCharArray()) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Altres m\u00e8todes del Reader s\u00f3n: int read(char[ ] buffer ) : llig un n\u00famero determinat de car\u00e0cters de l'entrada, guardant-los en el par\u00e0metre (que actuar\u00e0 com un buffer). El n\u00famero de car\u00e0cters llegits ser\u00e0 com a m\u00e0xim la grand\u00e0ria del buffer, encara que podria ser menor (si no hi ha prou car\u00e0cters, per exemple). El m\u00e8tode tornar\u00e0 el n\u00famero de car\u00e0cters que realment s'han llegit com un enter. Si no hi haguera cap car\u00e0cter disponible, es retornaria -1. int available() : indica quants car\u00e0cters hi ha disponibles per a la lectura. Sobretot serviria com a condici\u00f3 de final de bucle: si hi ha 0 car\u00e0cters disponibles, \u00e9s que ja hem acabat. Tot i aix\u00f2, hi ha altres maneres de fer la condici\u00f3 de final de bucle. long skip(long despl ) : salta, despreciant-los, tants car\u00e0cters com indica el par\u00e0metre. Podria ser que no puguera saltar el n\u00famero de car\u00e0cters especificat per diferents raons. Torna el n\u00famero de car\u00e0cters realment saltats. int close() : tanca el flux de dades. Mirem un altre exemple, utilitzant ara el buffer com a par\u00e0metre del read . \u00c9s id\u00e8ntic al de l'apartat del InputStream. La difer\u00e8ncia \u00e9s que ara s'haurien de llegir b\u00e9 tots els car\u00e0cters. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_23.kt : package exemples import java.io.FileReader fun main(args: Array<String>) { val f_in = FileReader(\"f2.txt\") var buffer = CharArray(30) var n = f_in.read(buffer) while (n != -1) { for (i in 0..n - 1) print(buffer[i].toChar()) println(\"\") n = f_in.read(buffer) } f_in.close(); } Es llegiran els car\u00e0cters de 30 en 30, ja que el buffer \u00e9s d'aquesta grand\u00e0ria. Com que ara es guarda en un buffer de car\u00e0cters, haurem de rec\u00f3rrer aquest buffer (fins el n\u00famero de car\u00e0cters llegits, que \u00e9s n ) . Hem suposat que en el fitxer f2.txt tenim un text prou llarg com per a veure el funcionament. Aquesta seria l'eixida: Hola. Aquest \u00e9s un text m\u00e9s ll arg, per veure com gestiona el s bytes amb un buffer de 30 ca r\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cte rs especials potser no isquen b\u00e9. Efectivament, s'han llegit tots els car\u00e0cters perfectament. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.2.1 - M\u00e8todes del Reader"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/221__mtodes_del_reader/#221-metodes-del-reader","text":"Els m\u00e8todes del Reader s\u00f3n absolutament similars als del InputStream . La difer\u00e8ncia \u00e9s que ara llegir\u00e0 sempre un car\u00e0cter. I no ens haurem de preocupar pel format en qu\u00e8 est\u00e0 guardat, i de i ocupa un o dos bytes. Sempre el llegir\u00e0 b\u00e9, siga quina siga la codificaci\u00f3 utilitzada, com ja hav\u00edem comentat abans: int read() : llig el seg\u00fcent car\u00e0cter del flux d'entrada i el retorna com un enter. Si no hi ha cap car\u00e0cter disponible perqu\u00e8 s\u2019ha assolit el final de la seq\u00fc\u00e8ncia, es retornar\u00e0 -1. Si no es pot llegir el seg\u00fcent car\u00e0cter per alguna causa (per exemple si despr\u00e9s d'arribar al final intentem llegir un altre car\u00e0cter, o perqu\u00e8 es produeix un error en llegir l'entrada) es llan\u00e7ar\u00e0 una excepci\u00f3 del tipus ** IOException **. Es tracta d\u2019un m\u00e8tode abstracte, que les classes especifiques sobreescriuran adaptant-lo a una font de dades concreta (un fitxer, un array de car\u00e0cters, ...). Abans de veure altres m\u00e8todes, mirem un exemple que \u00e9s id\u00e8ntic al primer exemple del InputStream, per\u00f2 canviant FileInputStream per FileReader. Llegir\u00e0 el mateix fitxer anomenat f1.txt , utilitzat en aquell moment, per\u00f2 ara segurament llegir\u00e0 tots els car\u00e0cters b\u00e9. El que far\u00e0 \u00e9s traure per pantalla car\u00e0cter a car\u00e0cter (en l\u00ednies diferents). Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_21.kt : package exemples import java.io.FileReader fun main(args: Array<String>){ val f_in = FileReader(\"f1.txt\") var c = f_in.read() while (c!=-1){ println(c.toChar()) c = f_in.read() } f_in.close() } Ara segurament s\u00ed que haur\u00e0 llegit b\u00e9 tots els car\u00e0cters, incloent \u00f1, \u00e7, vocals accentuades, etc. Si encara tenim el mateix contingut en f1.txt , el resultat ser\u00e0 ara: H o l a , q u \u00e8 t a l ? El m\u00e9s normal \u00e9s que en crear el fitxer f1.txt amb algun editor, el guardem amb la codificaci\u00f3 per defecte, que en cas de Windows \u00e9s ASCII (o ISO-8859) i en el cas de Linux \u00e9s UTF-8. I despr\u00e9s des de Java, el FileReader utilitzar\u00e0 la codificaci\u00f3 per defecte del Sistema Operatiu. \u00c9s a dir que en Linux el fitxer ha d'estar guardat en UTF-8 per a que el puga llegir b\u00e9, i en Windows en ASCII. Mirem tamb\u00e9 l'exemple equivalent al segon. All\u00e0 utilitz\u00e0vem un ByteArrayInputStream com a entrada. Ara podr\u00edem utilitzar un CharArrayReader , per\u00f2 ho farem amb un StringReader , i quedar\u00e0 m\u00e9s curt. A banda de que l'hem d'inicialitzar diferent, podem observar com el tractament posterior \u00e9s id\u00e8ntic. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_22.kt : package exemples import java.io.CharArrayReader fun main(args: Array<String>) { val ent_1 = \"Aquest \u00e9s un byte array\" val f_in = CharArrayReader(ent_1.toCharArray()) var c = f_in.read() while (c != -1) { println(c.toChar()) c = f_in.read() } f_in.close() } Altres m\u00e8todes del Reader s\u00f3n: int read(char[ ] buffer ) : llig un n\u00famero determinat de car\u00e0cters de l'entrada, guardant-los en el par\u00e0metre (que actuar\u00e0 com un buffer). El n\u00famero de car\u00e0cters llegits ser\u00e0 com a m\u00e0xim la grand\u00e0ria del buffer, encara que podria ser menor (si no hi ha prou car\u00e0cters, per exemple). El m\u00e8tode tornar\u00e0 el n\u00famero de car\u00e0cters que realment s'han llegit com un enter. Si no hi haguera cap car\u00e0cter disponible, es retornaria -1. int available() : indica quants car\u00e0cters hi ha disponibles per a la lectura. Sobretot serviria com a condici\u00f3 de final de bucle: si hi ha 0 car\u00e0cters disponibles, \u00e9s que ja hem acabat. Tot i aix\u00f2, hi ha altres maneres de fer la condici\u00f3 de final de bucle. long skip(long despl ) : salta, despreciant-los, tants car\u00e0cters com indica el par\u00e0metre. Podria ser que no puguera saltar el n\u00famero de car\u00e0cters especificat per diferents raons. Torna el n\u00famero de car\u00e0cters realment saltats. int close() : tanca el flux de dades. Mirem un altre exemple, utilitzant ara el buffer com a par\u00e0metre del read . \u00c9s id\u00e8ntic al de l'apartat del InputStream. La difer\u00e8ncia \u00e9s que ara s'haurien de llegir b\u00e9 tots els car\u00e0cters. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_23.kt : package exemples import java.io.FileReader fun main(args: Array<String>) { val f_in = FileReader(\"f2.txt\") var buffer = CharArray(30) var n = f_in.read(buffer) while (n != -1) { for (i in 0..n - 1) print(buffer[i].toChar()) println(\"\") n = f_in.read(buffer) } f_in.close(); } Es llegiran els car\u00e0cters de 30 en 30, ja que el buffer \u00e9s d'aquesta grand\u00e0ria. Com que ara es guarda en un buffer de car\u00e0cters, haurem de rec\u00f3rrer aquest buffer (fins el n\u00famero de car\u00e0cters llegits, que \u00e9s n ) . Hem suposat que en el fitxer f2.txt tenim un text prou llarg com per a veure el funcionament. Aquesta seria l'eixida: Hola. Aquest \u00e9s un text m\u00e9s ll arg, per veure com gestiona el s bytes amb un buffer de 30 ca r\u00e0cters. Com que ho llegim des d'un InputStream, els car\u00e0cte rs especials potser no isquen b\u00e9. Efectivament, s'han llegit tots els car\u00e0cters perfectament. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.2.1 - M\u00e8todes del Reader"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/222__mtodes_del_writer/","text":"2.2.2 - M\u00e8todes del Writer Comencem tamb\u00e9 pel m\u00e9s senzill i primordial, el m\u00e8tode que escriu un car\u00e0cter. void write( car : Int) : escriu el car\u00e0cter passat com a par\u00e0metre en el flux d'eixida. En cas que siga un FileWriter, escriur\u00e0 el car\u00e0cter amb la codificaci\u00f3 per defecte del S.O. : en Windows ISO-8839 i en Linux UTF-8. Si no es poguera fer l'escriptura per qualsevol motiu (per exemple, disc ple), es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus IOException . Igual que en l'apartat anterior, anem a veure un exemple senzill d'utilitzaci\u00f3, en el qual guardarem en un fitxer el contingut d'una cadena, ara ja sense por als car\u00e0cters estranys. En aquest primer exemple del Writer treballarem sobre un fitxer inexistent. Es podr\u00e0 comprovar que el resultat ser\u00e0 la creaci\u00f3 del fitxer amb el contingut. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_31.kt : Nota Hem de fer constar que si no es tanca el fitxer (millor dit el flux d'eixida) podria ser que no es guardara res en el fitxer. Per tant \u00e9s una operaci\u00f3 ben important que no hem d'oblidar. package exemples import java.io.FileWriter fun main(args: Array<String>) { val text = \"Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...\" val f_out = FileWriter (\"f5.txt\") for (c in text) { f_out.write(c.toInt()) } f_out.close() } En el constructor del Writer no hem indicat el segon par\u00e0metre, aquell que indicava si era per a afegir o no, i per tant si no existia el fitxer el crear\u00e0, per\u00f2 si ja existia el fitxer, destruir\u00e0 el seu contingut i el substituir\u00e0 pel nou contingut. Per aix\u00f2 si tornem a executar el programa, tindrem el mateix resultat en f5.txt Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ... Anem a provar a substituir el constructor, posant ara val f_out = FileWriter (\"f5.txt\", true) Si l'executem, veurem que afegir\u00e0 al final, sense destruir el que ja hi havia. Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ... Altres m\u00e8todes del Writer s\u00f3n: void write( buffer : CharArray) : escriu el contingut de l'array de car\u00e0cters al fitxer. Cal que buffer no siga nul, o provocarem un error. void write( buffer: CharArray , pos : Int, llarg : Int) : escriu al fitxer el contingut de l'array que est\u00e0 a partir de la posici\u00f3 pos i tants car\u00e0cters com assenyale llarg . void flush() : Guardar les dades en un fitxer \u00e9s una operaci\u00f3 relativament lenta, ja que \u00e9s accedir a un dispositiu lent (millor dit, no tan r\u00e0pid com la mem\u00f2ria). \u00c9s habitual que s'utilitze una mem\u00f2ria interm\u00e8dia per a que les coses no vagen tan lentes (com si f\u00f3ra una cach\u00e9). Per\u00f2 potser que les dades no estiguen guardades encara en el fitxer, sin\u00f3 que encara estiguen en aquesta cach\u00e9. El m\u00e8tode flush obliga a escriure els car\u00e0cters que queden encara a la cach\u00e9 f\u00edsicament al fitxer d'eixida. void close() : tanca el flux d'eixida, alliberant els recursos. Si quedava alguna cosa en la cach\u00e9, es guardar\u00e0 al fitxer i es tancar\u00e0 el flux. Aquestos m\u00e8todes s\u00f3n totalment similars als del OutputStream. A banda d'aquestos, el Writer t\u00e9 un altre, que pot ser especialment \u00fatil per a car\u00e0cters: void write( text : String) : escriu tot el contingut del String en el fitxer. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.2.2 - M\u00e8todes del Writer"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/222__mtodes_del_writer/#222-metodes-del-writer","text":"Comencem tamb\u00e9 pel m\u00e9s senzill i primordial, el m\u00e8tode que escriu un car\u00e0cter. void write( car : Int) : escriu el car\u00e0cter passat com a par\u00e0metre en el flux d'eixida. En cas que siga un FileWriter, escriur\u00e0 el car\u00e0cter amb la codificaci\u00f3 per defecte del S.O. : en Windows ISO-8839 i en Linux UTF-8. Si no es poguera fer l'escriptura per qualsevol motiu (per exemple, disc ple), es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus IOException . Igual que en l'apartat anterior, anem a veure un exemple senzill d'utilitzaci\u00f3, en el qual guardarem en un fitxer el contingut d'una cadena, ara ja sense por als car\u00e0cters estranys. En aquest primer exemple del Writer treballarem sobre un fitxer inexistent. Es podr\u00e0 comprovar que el resultat ser\u00e0 la creaci\u00f3 del fitxer amb el contingut. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_31.kt : Nota Hem de fer constar que si no es tanca el fitxer (millor dit el flux d'eixida) podria ser que no es guardara res en el fitxer. Per tant \u00e9s una operaci\u00f3 ben important que no hem d'oblidar. package exemples import java.io.FileWriter fun main(args: Array<String>) { val text = \"Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...\" val f_out = FileWriter (\"f5.txt\") for (c in text) { f_out.write(c.toInt()) } f_out.close() } En el constructor del Writer no hem indicat el segon par\u00e0metre, aquell que indicava si era per a afegir o no, i per tant si no existia el fitxer el crear\u00e0, per\u00f2 si ja existia el fitxer, destruir\u00e0 el seu contingut i el substituir\u00e0 pel nou contingut. Per aix\u00f2 si tornem a executar el programa, tindrem el mateix resultat en f5.txt Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ... Anem a provar a substituir el constructor, posant ara val f_out = FileWriter (\"f5.txt\", true) Si l'executem, veurem que afegir\u00e0 al final, sense destruir el que ja hi havia. Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ... Altres m\u00e8todes del Writer s\u00f3n: void write( buffer : CharArray) : escriu el contingut de l'array de car\u00e0cters al fitxer. Cal que buffer no siga nul, o provocarem un error. void write( buffer: CharArray , pos : Int, llarg : Int) : escriu al fitxer el contingut de l'array que est\u00e0 a partir de la posici\u00f3 pos i tants car\u00e0cters com assenyale llarg . void flush() : Guardar les dades en un fitxer \u00e9s una operaci\u00f3 relativament lenta, ja que \u00e9s accedir a un dispositiu lent (millor dit, no tan r\u00e0pid com la mem\u00f2ria). \u00c9s habitual que s'utilitze una mem\u00f2ria interm\u00e8dia per a que les coses no vagen tan lentes (com si f\u00f3ra una cach\u00e9). Per\u00f2 potser que les dades no estiguen guardades encara en el fitxer, sin\u00f3 que encara estiguen en aquesta cach\u00e9. El m\u00e8tode flush obliga a escriure els car\u00e0cters que queden encara a la cach\u00e9 f\u00edsicament al fitxer d'eixida. void close() : tanca el flux d'eixida, alliberant els recursos. Si quedava alguna cosa en la cach\u00e9, es guardar\u00e0 al fitxer i es tancar\u00e0 el flux. Aquestos m\u00e8todes s\u00f3n totalment similars als del OutputStream. A banda d'aquestos, el Writer t\u00e9 un altre, que pot ser especialment \u00fatil per a car\u00e0cters: void write( text : String) : escriu tot el contingut del String en el fitxer. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.2.2 - M\u00e8todes del Writer"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/22__fluxos_orientats_a_carcters/","text":"2.2 - Fluxos orientats a car\u00e0cters Treballar amb car\u00e0cters implica una dificultat apreciable, a causa sobretot de la diversitat de codificacions existents. Per poder solucionar-ho, Java disposa de dues jerarquies, una d'entrada i una d'eixida, diferents de les que ja hem vist per a bytes (que eren InputStream i OutputStream). Aquestes jerarquies per a car\u00e0cters seran molt semblants a les de bytes, per\u00f2 sempre orientades a car\u00e0cters. Kotlin, per heretar de Java, tamb\u00e9 les tindr\u00e0, encara que com veurem en l'\u00faltima pregunta, podrem simplificar les coses. Igual que en els casos anteriors, tindrem unes classes abstractes, Reader i Writer , que no es poden instanciar directament (no podrem crear un objecte d'aquestes classes). Serviran per a homogene\u00eftzar tots els fluxos d'entrada i d'exida orientats a car\u00e0cter. La super-classe Reader servir\u00e0 per a fer l'entrada des de qualsevol dispositiu: fitxer, array de car\u00e0cters, una canonada (\"tuberia\", per a dur dades des d'una altra aplicaci\u00f3). Totes les classes d'entrada heretaran d'ella, i serviran per especificar exactament d'on (per exemple un fitxer: FileReader ) o per a donar alguna altra funcionalitat, com anirem veient a poc a poc. D'aquesta manera, els m\u00e8todes que es defineixen s'hauran d'implementar per les classes que hereten d'ella i assegura una uniformitat, siga quina siga la font. Fem una ullada r\u00e0pida a la jerarquia de classes en la seg\u00fcent imatge: De moment mirem \u00fanicament les que estan en color taronja , que especificaran quina ser\u00e0 la font de dades: Classe Explicaci\u00f3 FileReader Per a llegir car\u00e0cters d'un fitxer *PipedReader * Per a llegir des d'una tuberia (\u00e9s a dir informaci\u00f3 que ve d'un altre programa) CharArray Reader**** L'entrada ser\u00e0 un array de car\u00e0cters StringReader L'entrada ser\u00e0 un string Evidentment ens centrarem en la primera, que \u00e9s la que m\u00e9s ens interessa per a la perman\u00e8ncia de les dades. Els fluxos d'eixida s\u00f3n molt molt pareguts, tots ells heretaran de Writer : Classe Explicaci\u00f3 FileWriter Per a guardar car\u00e0cters en un fitxer Piped Writer**** Per a traure cap a una tuberia (\u00e9s a dir informaci\u00f3 que anir\u00e0 a un altre programa) CharArray Writer**** L'eixida ser\u00e0 un array de car\u00e0cters StringWriter L'eixida ser\u00e0 un string Hem de fer constar que les classes d\u2019emmagatzematge intern (utilitzem Java o Kotlin), com ara CharArrayReader , CharArrayWriter , StringReader , StringWriter , PipedReader , PipedWriter utilitzen sempre la codificaci\u00f3 pr\u00f2pia de Java (unicode de 16 bits: UTF-16 ), ja que guarden les dades a la mem\u00f2ria basant-se en els tipus dades de tractament de car\u00e0cters de Java o Kotlin (C har i String ). En canvi les classes FileReader o FileWriter agafen la codificaci\u00f3 per defecte del sistema operatiu amfitri\u00f3 . L\u2019usuari no pot seleccionar diferents sistemes de codificaci\u00f3 en crear les inst\u00e0ncies. Aix\u00ed, una m\u00e0quina virtual Java sobre Windows utilitzar\u00e0, per defecte, la codificaci\u00f3 ISO-8859-1, per\u00f2 si corre sobre Linux, la codificaci\u00f3 ser\u00e0 UTF-8. De tota manera veurem que s\u00ed que podrem arribar a especificar quin \u00e9s el joc de car\u00e0cters que volem utilitzar en la pregunta 3.3. Intentarem veure exemples de tot. Constructors de FileReader De forma totalment paral\u00b7lela als fluxos orientats a byte, el FileReader t\u00e9 dos constructors, acceptant com a par\u00e0metre un File o un String (amb el nom del fitxer). La difer\u00e8ncia ara \u00e9s que la unitat de transfer\u00e8ncia ser\u00e0 el car\u00e0cter (en compte d'un byte): FileReader ( f : File) : en el par\u00e0metre se li passa un File (dels vistos en el tema anterior), que ha de ser una refer\u00e8ncia al fitxer. FileReader ( nom_f : String) : en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Ens permetr\u00e0 fer refer\u00e8ncia al fitxer de forma m\u00e9s r\u00e0pida, sense haver de passar per un File. Constructors del FileWriter Tamb\u00e9 totalment paral\u00b7lel al FileOutputStream. Canviaran lleugerament respecte als d'entrada, ja que a m\u00e9s de fer refer\u00e8ncia al fitxer, opcionalment podrem d'especificar la manera d'escriure en el fitxer en cas que aquest ja existesca: b\u00e9 afegint al final, o b\u00e9 destruint la informaci\u00f3 anterior. Aquestos s\u00f3n els constructors: FileWriter ( f : File) : en el par\u00e0metre se li passa un File. Si no existia, el crear\u00e0; si ja existia esborrar\u00e0 el contingut. En ambd\u00f3s casos l'obrir\u00e0 en mode escriptura. FileWriter ( nom_f : String) : igual que en l'anterior, per\u00f2 en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. File Writer (f: File , afegir : Boolean) : \u00e9s com el primer, per\u00f2 si en el segon par\u00e0metre se li passa true en compte de substituir el que ja hi havia, la informaci\u00f3 s'afegir\u00e0 al final. Si en aquest par\u00e0metre se li passa false s'esborrar\u00e0 el contingut anterior (com en el primer cas). File Writer (nom_f: String , __ afegir __ : Boolean) : igual que en l'anterior, per\u00f2 en el primer par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.2 - Fluxos orientats a car\u00e0cters"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/22__fluxos_orientats_a_carcters/#22-fluxos-orientats-a-caracters","text":"Treballar amb car\u00e0cters implica una dificultat apreciable, a causa sobretot de la diversitat de codificacions existents. Per poder solucionar-ho, Java disposa de dues jerarquies, una d'entrada i una d'eixida, diferents de les que ja hem vist per a bytes (que eren InputStream i OutputStream). Aquestes jerarquies per a car\u00e0cters seran molt semblants a les de bytes, per\u00f2 sempre orientades a car\u00e0cters. Kotlin, per heretar de Java, tamb\u00e9 les tindr\u00e0, encara que com veurem en l'\u00faltima pregunta, podrem simplificar les coses. Igual que en els casos anteriors, tindrem unes classes abstractes, Reader i Writer , que no es poden instanciar directament (no podrem crear un objecte d'aquestes classes). Serviran per a homogene\u00eftzar tots els fluxos d'entrada i d'exida orientats a car\u00e0cter. La super-classe Reader servir\u00e0 per a fer l'entrada des de qualsevol dispositiu: fitxer, array de car\u00e0cters, una canonada (\"tuberia\", per a dur dades des d'una altra aplicaci\u00f3). Totes les classes d'entrada heretaran d'ella, i serviran per especificar exactament d'on (per exemple un fitxer: FileReader ) o per a donar alguna altra funcionalitat, com anirem veient a poc a poc. D'aquesta manera, els m\u00e8todes que es defineixen s'hauran d'implementar per les classes que hereten d'ella i assegura una uniformitat, siga quina siga la font. Fem una ullada r\u00e0pida a la jerarquia de classes en la seg\u00fcent imatge: De moment mirem \u00fanicament les que estan en color taronja , que especificaran quina ser\u00e0 la font de dades: Classe Explicaci\u00f3 FileReader Per a llegir car\u00e0cters d'un fitxer *PipedReader * Per a llegir des d'una tuberia (\u00e9s a dir informaci\u00f3 que ve d'un altre programa) CharArray Reader**** L'entrada ser\u00e0 un array de car\u00e0cters StringReader L'entrada ser\u00e0 un string Evidentment ens centrarem en la primera, que \u00e9s la que m\u00e9s ens interessa per a la perman\u00e8ncia de les dades. Els fluxos d'eixida s\u00f3n molt molt pareguts, tots ells heretaran de Writer : Classe Explicaci\u00f3 FileWriter Per a guardar car\u00e0cters en un fitxer Piped Writer**** Per a traure cap a una tuberia (\u00e9s a dir informaci\u00f3 que anir\u00e0 a un altre programa) CharArray Writer**** L'eixida ser\u00e0 un array de car\u00e0cters StringWriter L'eixida ser\u00e0 un string Hem de fer constar que les classes d\u2019emmagatzematge intern (utilitzem Java o Kotlin), com ara CharArrayReader , CharArrayWriter , StringReader , StringWriter , PipedReader , PipedWriter utilitzen sempre la codificaci\u00f3 pr\u00f2pia de Java (unicode de 16 bits: UTF-16 ), ja que guarden les dades a la mem\u00f2ria basant-se en els tipus dades de tractament de car\u00e0cters de Java o Kotlin (C har i String ). En canvi les classes FileReader o FileWriter agafen la codificaci\u00f3 per defecte del sistema operatiu amfitri\u00f3 . L\u2019usuari no pot seleccionar diferents sistemes de codificaci\u00f3 en crear les inst\u00e0ncies. Aix\u00ed, una m\u00e0quina virtual Java sobre Windows utilitzar\u00e0, per defecte, la codificaci\u00f3 ISO-8859-1, per\u00f2 si corre sobre Linux, la codificaci\u00f3 ser\u00e0 UTF-8. De tota manera veurem que s\u00ed que podrem arribar a especificar quin \u00e9s el joc de car\u00e0cters que volem utilitzar en la pregunta 3.3. Intentarem veure exemples de tot. Constructors de FileReader De forma totalment paral\u00b7lela als fluxos orientats a byte, el FileReader t\u00e9 dos constructors, acceptant com a par\u00e0metre un File o un String (amb el nom del fitxer). La difer\u00e8ncia ara \u00e9s que la unitat de transfer\u00e8ncia ser\u00e0 el car\u00e0cter (en compte d'un byte): FileReader ( f : File) : en el par\u00e0metre se li passa un File (dels vistos en el tema anterior), que ha de ser una refer\u00e8ncia al fitxer. FileReader ( nom_f : String) : en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Ens permetr\u00e0 fer refer\u00e8ncia al fitxer de forma m\u00e9s r\u00e0pida, sense haver de passar per un File. Constructors del FileWriter Tamb\u00e9 totalment paral\u00b7lel al FileOutputStream. Canviaran lleugerament respecte als d'entrada, ja que a m\u00e9s de fer refer\u00e8ncia al fitxer, opcionalment podrem d'especificar la manera d'escriure en el fitxer en cas que aquest ja existesca: b\u00e9 afegint al final, o b\u00e9 destruint la informaci\u00f3 anterior. Aquestos s\u00f3n els constructors: FileWriter ( f : File) : en el par\u00e0metre se li passa un File. Si no existia, el crear\u00e0; si ja existia esborrar\u00e0 el contingut. En ambd\u00f3s casos l'obrir\u00e0 en mode escriptura. FileWriter ( nom_f : String) : igual que en l'anterior, per\u00f2 en el par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. File Writer (f: File , afegir : Boolean) : \u00e9s com el primer, per\u00f2 si en el segon par\u00e0metre se li passa true en compte de substituir el que ja hi havia, la informaci\u00f3 s'afegir\u00e0 al final. Si en aquest par\u00e0metre se li passa false s'esborrar\u00e0 el contingut anterior (com en el primer cas). File Writer (nom_f: String , __ afegir __ : Boolean) : igual que en l'anterior, per\u00f2 en el primer par\u00e0metre se li passa un String amb el nom (i la possible ruta) del fitxer. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.2 - Fluxos orientats a car\u00e0cters"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/2__manipulaci_dels_fluxos_de_dades/","text":"2 - Manipulaci\u00f3 dels fluxos de dades En Java, i per tant tamb\u00e9 en Kotlin, no tindrem una \u00fanica classe per a manipular els fluxos de dades i aix\u00ed arribar al contingut dels fitxers. \u00c9s una cosa que de vegades se li critica a Java, que hi ha una jerarquia molt extensa de fluxos, i s\u00f3n moltes classes a recordar i utilitzar. Per contra fa que siga molt vers\u00e0til. En l'\u00faltim punt del tema veurem la simplificaci\u00f3 que ens proposa Kotlin. Aquestes classes es trobaran en dues jerarquies, la dels fluxos orientats a bytes i la dels fluxos orientats a car\u00e0cters . Si les nostres dades s\u00f3n num\u00e8riques o de qualsevol altre tipus que puguem imaginar (imatges per exemple), ens convindran les primeres. Si la informaci\u00f3 \u00e9s de car\u00e0cters, haurem d'utilitzar la segona jerarquia. La ra\u00f3 de que existesca aquesta segona jerarquia orientada a car\u00e0cters \u00e9s la multitud de sistemes de codificaci\u00f3 existents. Com hav\u00edem comentat en la pregunta anterior, Java utilitza internament codificaci\u00f3 UNICODE de 16 bits (UTF-16), on cada car\u00e0cter ocupa 16 bits i aix\u00ed poder suportar tots els llenguatges com el grec, \u00e0rab, cir\u00edl\u00b7lic, xin\u00e8s, .... Per\u00f2 UTF-8 est\u00e0 molt est\u00e9s, i en aquesta codificaci\u00f3 de vegades un car\u00e0cter ocupa 8 bits, i de vegades 16. I no podem oblidar altres sistemes de codificaci\u00f3, com ASCII, ISO-8859, ... La jerarquia de classes orientades a car\u00e0cter suportar\u00e0 totes les codificacions. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2 - Manipulaci\u00f3 dels fluxos de dades"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/2__manipulaci_dels_fluxos_de_dades/#2-manipulacio-dels-fluxos-de-dades","text":"En Java, i per tant tamb\u00e9 en Kotlin, no tindrem una \u00fanica classe per a manipular els fluxos de dades i aix\u00ed arribar al contingut dels fitxers. \u00c9s una cosa que de vegades se li critica a Java, que hi ha una jerarquia molt extensa de fluxos, i s\u00f3n moltes classes a recordar i utilitzar. Per contra fa que siga molt vers\u00e0til. En l'\u00faltim punt del tema veurem la simplificaci\u00f3 que ens proposa Kotlin. Aquestes classes es trobaran en dues jerarquies, la dels fluxos orientats a bytes i la dels fluxos orientats a car\u00e0cters . Si les nostres dades s\u00f3n num\u00e8riques o de qualsevol altre tipus que puguem imaginar (imatges per exemple), ens convindran les primeres. Si la informaci\u00f3 \u00e9s de car\u00e0cters, haurem d'utilitzar la segona jerarquia. La ra\u00f3 de que existesca aquesta segona jerarquia orientada a car\u00e0cters \u00e9s la multitud de sistemes de codificaci\u00f3 existents. Com hav\u00edem comentat en la pregunta anterior, Java utilitza internament codificaci\u00f3 UNICODE de 16 bits (UTF-16), on cada car\u00e0cter ocupa 16 bits i aix\u00ed poder suportar tots els llenguatges com el grec, \u00e0rab, cir\u00edl\u00b7lic, xin\u00e8s, .... Per\u00f2 UTF-8 est\u00e0 molt est\u00e9s, i en aquesta codificaci\u00f3 de vegades un car\u00e0cter ocupa 8 bits, i de vegades 16. I no podem oblidar altres sistemes de codificaci\u00f3, com ASCII, ISO-8859, ... La jerarquia de classes orientades a car\u00e0cter suportar\u00e0 totes les codificacions. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2 - Manipulaci\u00f3 dels fluxos de dades"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/31__decoradors_de_inputstream_i_otputstream/","text":"3.1 - Decoradors de InputStream i OtputStream Com hem comentat ens serviran per a donar una funcionalitat extra. S\u00f3n els que estan de verd en la seg\u00fcent imatge: Fixem-nos primers en els decoradors de InputStream : Classe Explicaci\u00f3 FilterInputStream No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) LineNumberInputStream Afegeix el n\u00famero de l\u00ednia de cada l\u00ednia del InputStream (no la veurem) DataInputStream Permet llegir dades de qualsevol tipus de dades: enter, real, boole\u00e0, ... BufferedInputStream Munta un buffer d'entrada (no la veurem) PushBackInputStream Permet retrocedir un byte en la lectura, i per tant permet anar cap arrere (no la veurem) ObjectInputStream Permet llegir tot un objecte I de forma quasi paral\u00b7lela tenim els decoradors de OutputStream : Classe Explicaci\u00f3 FilterOutputStream No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) Data Out putStream Permet guardar al flux de dades d'eixida dades de qualsevol tipus: enter, real, boole\u00e0, ... Buffered Out putStream Munta un buffer d'eixida (no la veurem) PrintStream Permet escriure dades de diferents tipus, i t\u00e9 tamb\u00e9 els m\u00e8todes printf i println Object Out putStream Permet escriure (serialitzar) tot un objecte Comentem-los un poquet m\u00e9s. BufferedInputStream i BufferedOutputStream ens ofereixen un buffer d'entrada i d'eixida respectivament, per a fer la transfer\u00e8ncia m\u00e9s efectiva. En la pr\u00e0ctica ens oferir\u00e0 poques funcionalitats \u00fatils (a banda de l'efici\u00e8ncia en la transfer\u00e8ncia, clar). Quan anem als decoradors de fluxos orientats a car\u00e0cters, s\u00ed que trobarem utilitats als decoradors semblants a aquestos, com per exemple llegir o escriure una l\u00ednia sencera de car\u00e0cters. Per\u00f2 aquestos orientats a bytes, no els veurem. DataInputStream i DataOutputStream ens oferiran la possibilitat de llegir o escriure c\u00f2modament dades de diferents tipus: enter, real, boole\u00e0, strings, ... Els veurem en detall en el proper Tema 3 ObjectInputStream i ObjectOutputStream (que curiosament s\u00f3n els \u00fanics que no depenen de FilterInputStream i FilterOutputStream ) ens permetran guardar o recuperar de cop tot un objecte, \u00e9s a dir totes les seues propietats (les dades de l'objecte). No ens haurem de preocupar ni de l'ordre ni del tipus de les propietats de l'objecte: quan escrivim l'objecte, es guardaran totes les dades de forma compacta; i quan llegim es recuperaran de forma correcta. \u00c9s per tant una parella de classes d'extrema utilitat per a guardar objectes, que en definitiva s\u00f3n l'ess\u00e8ncia de la programaci\u00f3 en Java. Els veurem en detall en el proper Tema 3 . PrintStream L'\u00fanic que ens queda \u00e9s el que veurem ara amb un poquet m\u00e9s de detall, el PrintStream . Ens permetr\u00e0 b\u00e0sicament 3 coses: Escriure dades de m\u00e9s d'un tipus de dades. Per exemple print(5.25) escriu un n\u00famero real, i print(\"Hola\") escriu tot un string. Donar un determinat format a l'eixida, amb tota la funcionalitat a qu\u00e8 estem acostumats amb printf Escriure tota una l\u00ednia amb println , \u00e9s a dir, acabar una dada amb el retorn de carro, per a baixar de l\u00ednia. Mirem un exemple que ens pot donar idea de la seua funcionalitat. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_41.kt : package exemples import java.io.PrintStream import java.io.FileOutputStream fun main(args: Array<String>) { val f_out = PrintStream(FileOutputStream (\"f6.txt\")) val a = 5.25.toFloat() val b = \"Hola.\" f_out.print(b) f_out.println(\"Qu\u00e8 tal?\") f_out.println(a + 3) f_out.printf(\"El n\u00famero %d en hexadecimal \u00e9s %x\", 27, 27) f_out.close(); } Es crear\u00e0 el fitxer f6.txt (si ja existia esborrar\u00e0 el contingut anterior) amb el seg\u00fcent contingut: Hola.Qu\u00e8 tal? 8.25 El n\u00famero 27 en hexadecimal \u00e9s 1b En realitat el PrintStream , a banda del constructor que accepta un OutputStream , tamb\u00e9 t\u00e9 un altre que accepta un File i fins i tot un altre que accepta un String amb el nom del fitxer. Per tant, la seg\u00fcent sent\u00e8ncia tamb\u00e9 ens funcionaria: val f_out = PrintStream(\"f6.txt\") Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.1 - Decoradors de InputStream i OtputStream"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/31__decoradors_de_inputstream_i_otputstream/#31-decoradors-de-inputstream-i-otputstream","text":"Com hem comentat ens serviran per a donar una funcionalitat extra. S\u00f3n els que estan de verd en la seg\u00fcent imatge: Fixem-nos primers en els decoradors de InputStream : Classe Explicaci\u00f3 FilterInputStream No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) LineNumberInputStream Afegeix el n\u00famero de l\u00ednia de cada l\u00ednia del InputStream (no la veurem) DataInputStream Permet llegir dades de qualsevol tipus de dades: enter, real, boole\u00e0, ... BufferedInputStream Munta un buffer d'entrada (no la veurem) PushBackInputStream Permet retrocedir un byte en la lectura, i per tant permet anar cap arrere (no la veurem) ObjectInputStream Permet llegir tot un objecte I de forma quasi paral\u00b7lela tenim els decoradors de OutputStream : Classe Explicaci\u00f3 FilterOutputStream No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) Data Out putStream Permet guardar al flux de dades d'eixida dades de qualsevol tipus: enter, real, boole\u00e0, ... Buffered Out putStream Munta un buffer d'eixida (no la veurem) PrintStream Permet escriure dades de diferents tipus, i t\u00e9 tamb\u00e9 els m\u00e8todes printf i println Object Out putStream Permet escriure (serialitzar) tot un objecte Comentem-los un poquet m\u00e9s. BufferedInputStream i BufferedOutputStream ens ofereixen un buffer d'entrada i d'eixida respectivament, per a fer la transfer\u00e8ncia m\u00e9s efectiva. En la pr\u00e0ctica ens oferir\u00e0 poques funcionalitats \u00fatils (a banda de l'efici\u00e8ncia en la transfer\u00e8ncia, clar). Quan anem als decoradors de fluxos orientats a car\u00e0cters, s\u00ed que trobarem utilitats als decoradors semblants a aquestos, com per exemple llegir o escriure una l\u00ednia sencera de car\u00e0cters. Per\u00f2 aquestos orientats a bytes, no els veurem. DataInputStream i DataOutputStream ens oferiran la possibilitat de llegir o escriure c\u00f2modament dades de diferents tipus: enter, real, boole\u00e0, strings, ... Els veurem en detall en el proper Tema 3 ObjectInputStream i ObjectOutputStream (que curiosament s\u00f3n els \u00fanics que no depenen de FilterInputStream i FilterOutputStream ) ens permetran guardar o recuperar de cop tot un objecte, \u00e9s a dir totes les seues propietats (les dades de l'objecte). No ens haurem de preocupar ni de l'ordre ni del tipus de les propietats de l'objecte: quan escrivim l'objecte, es guardaran totes les dades de forma compacta; i quan llegim es recuperaran de forma correcta. \u00c9s per tant una parella de classes d'extrema utilitat per a guardar objectes, que en definitiva s\u00f3n l'ess\u00e8ncia de la programaci\u00f3 en Java. Els veurem en detall en el proper Tema 3 . PrintStream L'\u00fanic que ens queda \u00e9s el que veurem ara amb un poquet m\u00e9s de detall, el PrintStream . Ens permetr\u00e0 b\u00e0sicament 3 coses: Escriure dades de m\u00e9s d'un tipus de dades. Per exemple print(5.25) escriu un n\u00famero real, i print(\"Hola\") escriu tot un string. Donar un determinat format a l'eixida, amb tota la funcionalitat a qu\u00e8 estem acostumats amb printf Escriure tota una l\u00ednia amb println , \u00e9s a dir, acabar una dada amb el retorn de carro, per a baixar de l\u00ednia. Mirem un exemple que ens pot donar idea de la seua funcionalitat. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_41.kt : package exemples import java.io.PrintStream import java.io.FileOutputStream fun main(args: Array<String>) { val f_out = PrintStream(FileOutputStream (\"f6.txt\")) val a = 5.25.toFloat() val b = \"Hola.\" f_out.print(b) f_out.println(\"Qu\u00e8 tal?\") f_out.println(a + 3) f_out.printf(\"El n\u00famero %d en hexadecimal \u00e9s %x\", 27, 27) f_out.close(); } Es crear\u00e0 el fitxer f6.txt (si ja existia esborrar\u00e0 el contingut anterior) amb el seg\u00fcent contingut: Hola.Qu\u00e8 tal? 8.25 El n\u00famero 27 en hexadecimal \u00e9s 1b En realitat el PrintStream , a banda del constructor que accepta un OutputStream , tamb\u00e9 t\u00e9 un altre que accepta un File i fins i tot un altre que accepta un String amb el nom del fitxer. Per tant, la seg\u00fcent sent\u00e8ncia tamb\u00e9 ens funcionaria: val f_out = PrintStream(\"f6.txt\") Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.1 - Decoradors de InputStream i OtputStream"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/32__decoradors_de_reader_i_writer/","text":"3.2 - Decoradors de Reader i Writer Mirem ara els decoradors de la jerarquia Reader i Writer . Tornen a ser els de color verd. Els de color gris InputStreamReader i OutputStreamWriter s\u00f3n conversors que permeten passar un InputStream a un Reader i un OutputStream a Writer . Els veurem en la seg\u00fcent pregunta. Fixem-nos primers en els decoradors de Reader : Classe Explicaci\u00f3 FilterReader No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) PushBackInputStream Permet retrocedir un car\u00e0cter en la lectura, i per tant permet anar cap arrere (no la veurem) Buffered Reader**** Munta un buffer d'entrada, i permet entre altres coses llegir una l\u00ednia sencera LineNumber Reader**** Afegeix el n\u00famero de l\u00ednia de cada l\u00ednia del fitxer (no la veurem) I de forma quasi paral\u00b7lela tenim els decoradors de Writer : Classe Explicaci\u00f3 FilterWriter No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) Buffered Writer**** Munta un buffer d'eixida, i permet entre altres coses escriure una l\u00ednia sencera Print Writer**** Permet escriure dades de diferents tipus, i t\u00e9 tamb\u00e9 els m\u00e8todes printf i println El PrintWriter funciona quasi exactament igual que el PrintStream , i per a car\u00e0cters \u00e9s m\u00e9s \u00fatil que l'altre (per ser Writer ), per tant \u00e9s el candidat a recordar. El BufferedReader s\u00ed que ens oferir\u00e0 facilitats interessants, com llegir una l\u00ednia sencera. En canvi el BufferedWriter no ens ofereix tantes facilitats com el PrintWriter , \u00e9s un poc m\u00e9s inc\u00f2mode. BufferedReader i BufferedWriter. PrintWriter BufferedReader i BufferedWriter munten un buffer (d'entrada i d'eixida respectivament) de car\u00e0cters per a fer m\u00e9s eficient la transfer\u00e8ncia. A banda d'aix\u00f2 tindran uns m\u00e8todes que ens seran molt \u00fatils. BufferedReader m\u00e8tode readLine() que ens permet llegir una l\u00ednia sencera del fitxer (fins al final de l\u00ednia). A\u00e7\u00f2 \u00e9s de molta utilitat en els fitxers de text. BufferedWriter m\u00e8tode newLine() que permet introduir el car\u00e0cter de baixada de l\u00ednia m\u00e8tode write( cad : String, com : Int, llarg : Int) que permet escriure tot un string, o una part d'ell, especificant on comen\u00e7a el que volem escriure i la llarg\u00e0ria Com veieu el BufferedReader s\u00ed que ens ofereix la possibilitat de llegir una l\u00ednia sencera, per\u00f2 en canvi el BufferedWriter es queda un poc curt. Per aix\u00f2 preferirem el PrintWriter . PrintWriter m\u00e8todes print( qualsevol_tipu s ) , que permeten imprimir una dada de qualsevol tipus: boole\u00e0, char, tots els num\u00e8rics, string, ... Ser\u00e0 segurament el que m\u00e9s utilitzarem. m\u00e8todes println ( qualsevol_tipu s ) * , a banda de tot el de *print , baixen de l\u00ednia m\u00e8tode printf() , que permet donar un format Veiem un senzill exemple per a copiar el contingut d'un fitxer de text i modificar-lo lleugerament. El m\u00e9s c\u00f2mode ser\u00e0 anar l\u00ednia a l\u00ednia. Per tant utilitzarem el BufferedReader per a llegir l\u00ednies, i el PrintWriter per a escriure l\u00ednies. La lleugera modificaci\u00f3 consistir\u00e0 en posar el n\u00famero de l\u00ednia davant. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_51.kt : package exemples import java.io.BufferedReader import java.io.FileReader import java.io.PrintWriter import java.io.FileWriter fun main(args: Array<String>) { val f_ent = BufferedReader(FileReader (\"f7_ent.txt\")) val f_eix = PrintWriter(FileWriter (\"f7_eix.txt\")) var cad = f_ent.readLine(); var i = 0 while (cad != null) { i++ f_eix.println(\"\" + i + \".- \" + cad) cad = f_ent.readLine() } f_eix.close() f_ent.close() } Si en el fitxer d'entrada ( f7_ent.txt ) tenim guardada la seg\u00fcent informaci\u00f3 (introdu\u00efda amb el notepad o gedit): Primera Segona Tercera En el fitxer d'eixida ( f7_eix.txt ) tindrem: 1.- Primera 2.- Segona 3.- Tercera Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.2 - Decoradors de Reader i Writer"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/32__decoradors_de_reader_i_writer/#32-decoradors-de-reader-i-writer","text":"Mirem ara els decoradors de la jerarquia Reader i Writer . Tornen a ser els de color verd. Els de color gris InputStreamReader i OutputStreamWriter s\u00f3n conversors que permeten passar un InputStream a un Reader i un OutputStream a Writer . Els veurem en la seg\u00fcent pregunta. Fixem-nos primers en els decoradors de Reader : Classe Explicaci\u00f3 FilterReader No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) PushBackInputStream Permet retrocedir un car\u00e0cter en la lectura, i per tant permet anar cap arrere (no la veurem) Buffered Reader**** Munta un buffer d'entrada, i permet entre altres coses llegir una l\u00ednia sencera LineNumber Reader**** Afegeix el n\u00famero de l\u00ednia de cada l\u00ednia del fitxer (no la veurem) I de forma quasi paral\u00b7lela tenim els decoradors de Writer : Classe Explicaci\u00f3 FilterWriter No \u00e9s instanciable, \u00fanicament est\u00e0 per a que les altres depenguen d'ella (no la veurem) Buffered Writer**** Munta un buffer d'eixida, i permet entre altres coses escriure una l\u00ednia sencera Print Writer**** Permet escriure dades de diferents tipus, i t\u00e9 tamb\u00e9 els m\u00e8todes printf i println El PrintWriter funciona quasi exactament igual que el PrintStream , i per a car\u00e0cters \u00e9s m\u00e9s \u00fatil que l'altre (per ser Writer ), per tant \u00e9s el candidat a recordar. El BufferedReader s\u00ed que ens oferir\u00e0 facilitats interessants, com llegir una l\u00ednia sencera. En canvi el BufferedWriter no ens ofereix tantes facilitats com el PrintWriter , \u00e9s un poc m\u00e9s inc\u00f2mode. BufferedReader i BufferedWriter. PrintWriter BufferedReader i BufferedWriter munten un buffer (d'entrada i d'eixida respectivament) de car\u00e0cters per a fer m\u00e9s eficient la transfer\u00e8ncia. A banda d'aix\u00f2 tindran uns m\u00e8todes que ens seran molt \u00fatils. BufferedReader m\u00e8tode readLine() que ens permet llegir una l\u00ednia sencera del fitxer (fins al final de l\u00ednia). A\u00e7\u00f2 \u00e9s de molta utilitat en els fitxers de text. BufferedWriter m\u00e8tode newLine() que permet introduir el car\u00e0cter de baixada de l\u00ednia m\u00e8tode write( cad : String, com : Int, llarg : Int) que permet escriure tot un string, o una part d'ell, especificant on comen\u00e7a el que volem escriure i la llarg\u00e0ria Com veieu el BufferedReader s\u00ed que ens ofereix la possibilitat de llegir una l\u00ednia sencera, per\u00f2 en canvi el BufferedWriter es queda un poc curt. Per aix\u00f2 preferirem el PrintWriter . PrintWriter m\u00e8todes print( qualsevol_tipu s ) , que permeten imprimir una dada de qualsevol tipus: boole\u00e0, char, tots els num\u00e8rics, string, ... Ser\u00e0 segurament el que m\u00e9s utilitzarem. m\u00e8todes println ( qualsevol_tipu s ) * , a banda de tot el de *print , baixen de l\u00ednia m\u00e8tode printf() , que permet donar un format Veiem un senzill exemple per a copiar el contingut d'un fitxer de text i modificar-lo lleugerament. El m\u00e9s c\u00f2mode ser\u00e0 anar l\u00ednia a l\u00ednia. Per tant utilitzarem el BufferedReader per a llegir l\u00ednies, i el PrintWriter per a escriure l\u00ednies. La lleugera modificaci\u00f3 consistir\u00e0 en posar el n\u00famero de l\u00ednia davant. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_51.kt : package exemples import java.io.BufferedReader import java.io.FileReader import java.io.PrintWriter import java.io.FileWriter fun main(args: Array<String>) { val f_ent = BufferedReader(FileReader (\"f7_ent.txt\")) val f_eix = PrintWriter(FileWriter (\"f7_eix.txt\")) var cad = f_ent.readLine(); var i = 0 while (cad != null) { i++ f_eix.println(\"\" + i + \".- \" + cad) cad = f_ent.readLine() } f_eix.close() f_ent.close() } Si en el fitxer d'entrada ( f7_ent.txt ) tenim guardada la seg\u00fcent informaci\u00f3 (introdu\u00efda amb el notepad o gedit): Primera Segona Tercera En el fitxer d'eixida ( f7_eix.txt ) tindrem: 1.- Primera 2.- Segona 3.- Tercera Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.2 - Decoradors de Reader i Writer"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/33__conversors_inputstreamreader_i_outputstreamwriter/","text":"3.3 - Conversors: InputStreamReader i OutputStreamWriter Una vegada vistes les jerarquies de les classes InputStream-OutputStream per una banda, i Reader-Writer per una altra, veurem ara unes classes que serviran per a passar d'una jeraquia a una altra. \u00c9s a dir, poder passar un InputStream a Reader , o el que \u00e9s el mateix, un flux orientat a bytes en un flux orientat a car\u00e0cters. I el mateix amb el OutputStream i el Writer. InputStreamReader : passa un InputStream a Reader . Accepta com a par\u00e0metre el InputStream i d\u00f3na com a resultat un Reader . OutputStreamWriter : passa un OutputStream a Writer . Accepta com a par\u00e0metre el OutputStream i d\u00f3na com a resultat un Writer . A m\u00e9s en el constructor dels dos, InputStreamReader i OutputStreamWriter , tenim la possibilitat d'especificar el tipus de codificaci\u00f3, a m\u00e9s del InputStream o OutputStream. A\u00e7\u00f2 ens ser\u00e0 molt \u00fatil, perqu\u00e8 fins el moment no pod\u00edem triar el tipus de codificaci\u00f3 d'un FileReader o FileWriter que era UTF-8 en el cas de Linux, i ASCII (millor dit la seua extensi\u00f3 ISO-8859-1) en el cas de Windows. Mirem aquest exemple, en el qual transformem el mateix fitxer d'una configuraci\u00f3 a una altra. Aprofitem algun dels fitxers que ja disposem (per exemple f5.txt, que tenia car\u00e0cters especials com vocals accentuades). En l'exemple el tindrem en codificaci\u00f3 UTF-8, ja que est\u00e0 provat en Linux. El transformarem a ISO-8859-1. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_61.kt : package exemples import java.io.InputStreamReader import java.io.FileInputStream import java.io.OutputStreamWriter import java.io.FileOutputStream fun main(args: Array<String>) { val f_ent = InputStreamReader(FileInputStream(\"f5.txt\"), \"UTF-8\") val f_eix = OutputStreamWriter(FileOutputStream(\"f5_ISO.txt\"), \"ISO-8859-1\") var car = f_ent.read() while (car != -1) { f_eix.write(car) car = f_ent.read() } f_eix.close() f_ent.close() } Hem posat l'entrada expl\u00edcitament que siga de UTF-8. En realitat no faria falta, ja que si treballem en Linux, aquesta ser\u00e0 la codificaci\u00f3 per defecte, i per tant seria la que utilitzaria un FileReader. FileReader f_ent = new FileReader(\"f5.txt\") Anem a fer una altra versi\u00f3 del mateix programa. A banda de no especificar la codificaci\u00f3 del fitxer d'entrada, utilitzarem els decoradors BufferedReader i PrintWriter per a poder anar c\u00f2modament l\u00ednia a l\u00ednia. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_62.kt : package exemples import java.io.FileReader import java.io.BufferedReader import java.io.FileOutputStream import java.io.OutputStreamWriter import java.io.PrintWriter fun main(args: Array<String>) { val f_ent = BufferedReader(FileReader (\"f5.txt\")) val f_eix = PrintWriter(OutputStreamWriter(FileOutputStream (\"f5_ISO.txt\"), \"ISO-8859-1\")) var cad = f_ent.readLine() while (cad != null) { f_eix.println(cad) cad = f_ent.readLine() } f_eix.close() f_ent.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.3 - ConversorsInputStreamReader i OutputStreamWriter"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/33__conversors_inputstreamreader_i_outputstreamwriter/#33-conversors-inputstreamreader-i-outputstreamwriter","text":"Una vegada vistes les jerarquies de les classes InputStream-OutputStream per una banda, i Reader-Writer per una altra, veurem ara unes classes que serviran per a passar d'una jeraquia a una altra. \u00c9s a dir, poder passar un InputStream a Reader , o el que \u00e9s el mateix, un flux orientat a bytes en un flux orientat a car\u00e0cters. I el mateix amb el OutputStream i el Writer. InputStreamReader : passa un InputStream a Reader . Accepta com a par\u00e0metre el InputStream i d\u00f3na com a resultat un Reader . OutputStreamWriter : passa un OutputStream a Writer . Accepta com a par\u00e0metre el OutputStream i d\u00f3na com a resultat un Writer . A m\u00e9s en el constructor dels dos, InputStreamReader i OutputStreamWriter , tenim la possibilitat d'especificar el tipus de codificaci\u00f3, a m\u00e9s del InputStream o OutputStream. A\u00e7\u00f2 ens ser\u00e0 molt \u00fatil, perqu\u00e8 fins el moment no pod\u00edem triar el tipus de codificaci\u00f3 d'un FileReader o FileWriter que era UTF-8 en el cas de Linux, i ASCII (millor dit la seua extensi\u00f3 ISO-8859-1) en el cas de Windows. Mirem aquest exemple, en el qual transformem el mateix fitxer d'una configuraci\u00f3 a una altra. Aprofitem algun dels fitxers que ja disposem (per exemple f5.txt, que tenia car\u00e0cters especials com vocals accentuades). En l'exemple el tindrem en codificaci\u00f3 UTF-8, ja que est\u00e0 provat en Linux. El transformarem a ISO-8859-1. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_61.kt : package exemples import java.io.InputStreamReader import java.io.FileInputStream import java.io.OutputStreamWriter import java.io.FileOutputStream fun main(args: Array<String>) { val f_ent = InputStreamReader(FileInputStream(\"f5.txt\"), \"UTF-8\") val f_eix = OutputStreamWriter(FileOutputStream(\"f5_ISO.txt\"), \"ISO-8859-1\") var car = f_ent.read() while (car != -1) { f_eix.write(car) car = f_ent.read() } f_eix.close() f_ent.close() } Hem posat l'entrada expl\u00edcitament que siga de UTF-8. En realitat no faria falta, ja que si treballem en Linux, aquesta ser\u00e0 la codificaci\u00f3 per defecte, i per tant seria la que utilitzaria un FileReader. FileReader f_ent = new FileReader(\"f5.txt\") Anem a fer una altra versi\u00f3 del mateix programa. A banda de no especificar la codificaci\u00f3 del fitxer d'entrada, utilitzarem els decoradors BufferedReader i PrintWriter per a poder anar c\u00f2modament l\u00ednia a l\u00ednia. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_2_62.kt : package exemples import java.io.FileReader import java.io.BufferedReader import java.io.FileOutputStream import java.io.OutputStreamWriter import java.io.PrintWriter fun main(args: Array<String>) { val f_ent = BufferedReader(FileReader (\"f5.txt\")) val f_eix = PrintWriter(OutputStreamWriter(FileOutputStream (\"f5_ISO.txt\"), \"ISO-8859-1\")) var cad = f_ent.readLine() while (cad != null) { f_eix.println(cad) cad = f_ent.readLine() } f_eix.close() f_ent.close() } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.3 - Conversors: InputStreamReader i OutputStreamWriter"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/3__fluxos_decoradors/","text":"3 - Fluxos decoradors Anomenem classes \" decoradores \" a aquelles que hereten d'una classe determinada i serveixen per a dotar d'una funcionalitat extra que no tenia la classe original. En els fluxos, en els d'entrada i en els d'eixida, veurem uns quants \"decoradors\" que ens permetran una funcionalitat extra: llegir o escriure una l\u00ednia sencera (en compte de byte a byte, o car\u00e0cter a car\u00e0cter), o guardar amb determinat format de dades, ... En el cas de car\u00e0cters tamb\u00e9 ens permetran triar la codificaci\u00f3 (ISO-8859-1, UTF-8, UTF-16, ...). Anirem veient-los poc a poc, classificats per la classe arrel, \u00e9s a dir, per una banda els decoradors del InputStream i OutputStream (orientats a byte), i per una altra banda els de Reader i Writer (orientats a car\u00e0cter) Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3 - Fluxos decoradors"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/3__fluxos_decoradors/#3-fluxos-decoradors","text":"Anomenem classes \" decoradores \" a aquelles que hereten d'una classe determinada i serveixen per a dotar d'una funcionalitat extra que no tenia la classe original. En els fluxos, en els d'entrada i en els d'eixida, veurem uns quants \"decoradors\" que ens permetran una funcionalitat extra: llegir o escriure una l\u00ednia sencera (en compte de byte a byte, o car\u00e0cter a car\u00e0cter), o guardar amb determinat format de dades, ... En el cas de car\u00e0cters tamb\u00e9 ens permetran triar la codificaci\u00f3 (ISO-8859-1, UTF-8, UTF-16, ...). Anirem veient-los poc a poc, classificats per la classe arrel, \u00e9s a dir, per una banda els decoradors del InputStream i OutputStream (orientats a byte), i per una altra banda els de Reader i Writer (orientats a car\u00e0cter) Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3 - Fluxos decoradors"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/4__simplificaci_en_kotlin/","text":"4 - Simplificaci\u00f3 en Kotlin Tots els programes anteriors funcionen en Kotlin perfectament, perqu\u00e8 estem utilitzant les classes de Java, i aquestes sense problemes funcionen en Kotlin, \u00e9s una de les seues caracter\u00edstiques. Tanmateix, Kotlin proporcionar\u00e0 funcionalitat extra en les classes, que ens permetr\u00e0 simplificar prou els programes. S\u00f3n molts els m\u00e8todes nous que ens proporcionar\u00e0. Ac\u00ed tenim uns quants agrupats per tem\u00e0tica. M\u00e8todes sobre bytes readBytes() : torna un ByteArray amb tots els bytes del fitxer, \u00e9s a dir, tot el seu contingut en forma de bytes writeBytes( array : ByteArray) : escriu en el fitxer el contingut del ByteArray. Si el fitxer ja existia, el sobreescriura. appendBytes ( array : ByteArray) : afegeix al final del fitxer els bytes del ByteArray. Tornem a fer el primer exemple, Exemple_2_01.kt, utilitzant aquesta funcionalitat extra. Copieu el seg\u00fcent com Exemple_2_01_bis.kt : package exemples import java.io.File fun main(){ val f = File(\"f1.txt\") val tot = f.readBytes() for (c in tot){ println(c.toChar()) } } I com a exemple d'escriptura, podem fer Exemple_2_11.kt,on ho podem fer tot en una l\u00ednia. Copieu el seg\u00fcent com Exemple_2_11_bis.kt : package exemples import java.io.File fun main() { val text = \"Contingut per al fitxer.\" File(\"f3.txt\").writeBytes(text.toByteArray()) } Recordeu que en els dos exemples anteriors per comoditat estem utilitzant car\u00e0cters com a dades, i no seria el m\u00e9s correcte utilitzar bytes ni de lectura ni d'escriptura. Ho hem fet \u00fanicament per comoditat. M\u00e8todes sobre car\u00e0cters readText( charset : CharSet) : torna un String amb la tots els car\u00e0cters del fitxer. Opcionalment li podem dir el joc de car\u00e0cters (si no li ho diem utilitzar\u00e0 UTF-8) readLines( charset : CharSet) : torna un List de Strings amb totes les l\u00ednies del fitxer writeText( text : String, charset : CharSet) : escriu el string en el fitxer. Si el fitxer ja existia el sobreescriur\u00e0. Opcionalment podem posar el joc de car\u00e0cters que volem utilitzar. Si no el posem utilitzar\u00e0 UTF-8. Observeu que ja dispos\u00e0vem d'un m\u00e8tode que escrivia tot un String anteriorment, per tant no \u00e9s una gran millora, excepte pel fet de poder especificar el joc de car\u00e0cters. A\u00e7\u00f2 s\u00ed que \u00e9s de gran comoditat. appendText( text : String, charset : CharSet) : el mateix que l'anterior, per\u00f2 afegint al final. Com a exemple anem a veure Exemple_2_21.kt. Copieu el seg\u00fcent com Exemple_2_21_bis.kt : package exemples import java.io.File fun main(){ val tot = File(\"f1.txt\").readText() for(c in tot){ println(c) } } I com a exemple d'escriptura, l'adaptaci\u00f3 de Exemple_2_31.kt. Copieu el seg\u00fcent com Exemple_2_31_bis.kt : package exemples import java.io.File fun main() { val text = \"Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...\" File(\"f5.txt\").writeText(text) } I com a exemple de copiar un fitxer en un altre, fins i tot canviant el joc de car\u00e0cters, farem una altra versi\u00f3 del Exemple_2_61.kt. Copieu el seg\u00fcent com Exemple_2_61_bis.kt : package exemples import java.io.File fun main() { File(\"f5_2.txt\").writeText(File(\"f5.txt\").readText(), Charsets.ISO_8859_1) } M\u00e8todes de conversi\u00f3 En ocasions \u00e9s possible que no tinguem un m\u00e8tode directament en File que ens vinga b\u00e9. Un exemple s\u00f3n els m\u00e8todes print (print, println, printf). Aleshores, senzillament a partir del File la classe que ens convinga de la jerarquia de InputStream/OutputStream o Reader/Writer. S\u00f3n m\u00e8todes que ens tornen la classe desitjada: inputStream() : construeix in un InputStream que apunta al File, i el torna inputStream() : el mateix amb un OutputStream reader( charset : Charset) : el mateix amb un Reader, tenint la possibilitat d'especificar el joc de car\u00e0cters (si no s'especifica ser\u00e0 UTF-8) writer( charset : Charset) : el mateix amb un Writer bufferedReader( charset : Charset) : el mateix amb un BufferedReader printWriter( charset : Charset) : el mateix amb un Writer Per exemple, el que hem comentat m\u00e9s amunt: si volem els m\u00e8todes print, senzillament obtenim un PrintWriter a partir del File. D'aquesta manera, el Exemple_2_41.kt ens quedaria d'una altra manera per a obtenir el PrintWriter que vol\u00edem. Copieu el seg\u00fcent com Exemple_2_41_bis.kt : package exemples import java.io.File fun main() { val f_out = File(\"f6.txt\").printWriter() val a = 5.25.toFloat() val b = \"Hola.\" f_out.print(b) f_out.println(\"Qu\u00e8 tal?\") f_out.println(a + 3) f_out.printf(\"El n\u00famero %d en hexadecimal \u00e9s %x\", 27, 27) f_out.close(); } Altres m\u00e8todes Hi ha altres m\u00e8todes que poden ser molt \u00fatils. Per exemple aquell que copia directament un fitxer, o tot un directori recursivament, o que esborra recursivament, ... copyTo( dest\u00ed : File, sobre_escriure : Boolean, buffer : Int) : copia en el fitxer de dest\u00ed. Per defecte no sobreescriur\u00e0, a no ser que posem true en el segon par\u00e0mentre. El tercer par\u00e0metre \u00e9s per a marcar la grand\u00e0ria del buffer de dades per a fer la c\u00f2pia. copyRecursively( dest\u00ed : File, sobre_escriure : Boolean) : copia recursivament el File i tots els seus descendents en el File de dest\u00ed. Per defecte no sobreescriur\u00e0, a menys que posem true en el segon par\u00e0mentre. Opcionalment es pot posar un tercer par\u00e0metre per al tractament dels possibles errors deleteRecursively(): esborra el file i tots els seus possibles descendents Tamb\u00e9 hi ha altres m\u00e8todes, com per exemple per a comprovar si el nom del File t\u00e9 extensi\u00f3, o si comen\u00e7a o finalitza igual que un altre, o per a normalitzar la ruta (llevar possibles redund\u00e0ncies), i altre m\u00e9s. Es poden consultar totes les extensions que proporciona Kotline a la classe File en: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/ Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4 - Simplificaci\u00f3 en Kotlin"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/4__simplificaci_en_kotlin/#4-simplificacio-en-kotlin","text":"Tots els programes anteriors funcionen en Kotlin perfectament, perqu\u00e8 estem utilitzant les classes de Java, i aquestes sense problemes funcionen en Kotlin, \u00e9s una de les seues caracter\u00edstiques. Tanmateix, Kotlin proporcionar\u00e0 funcionalitat extra en les classes, que ens permetr\u00e0 simplificar prou els programes. S\u00f3n molts els m\u00e8todes nous que ens proporcionar\u00e0. Ac\u00ed tenim uns quants agrupats per tem\u00e0tica. M\u00e8todes sobre bytes readBytes() : torna un ByteArray amb tots els bytes del fitxer, \u00e9s a dir, tot el seu contingut en forma de bytes writeBytes( array : ByteArray) : escriu en el fitxer el contingut del ByteArray. Si el fitxer ja existia, el sobreescriura. appendBytes ( array : ByteArray) : afegeix al final del fitxer els bytes del ByteArray. Tornem a fer el primer exemple, Exemple_2_01.kt, utilitzant aquesta funcionalitat extra. Copieu el seg\u00fcent com Exemple_2_01_bis.kt : package exemples import java.io.File fun main(){ val f = File(\"f1.txt\") val tot = f.readBytes() for (c in tot){ println(c.toChar()) } } I com a exemple d'escriptura, podem fer Exemple_2_11.kt,on ho podem fer tot en una l\u00ednia. Copieu el seg\u00fcent com Exemple_2_11_bis.kt : package exemples import java.io.File fun main() { val text = \"Contingut per al fitxer.\" File(\"f3.txt\").writeBytes(text.toByteArray()) } Recordeu que en els dos exemples anteriors per comoditat estem utilitzant car\u00e0cters com a dades, i no seria el m\u00e9s correcte utilitzar bytes ni de lectura ni d'escriptura. Ho hem fet \u00fanicament per comoditat. M\u00e8todes sobre car\u00e0cters readText( charset : CharSet) : torna un String amb la tots els car\u00e0cters del fitxer. Opcionalment li podem dir el joc de car\u00e0cters (si no li ho diem utilitzar\u00e0 UTF-8) readLines( charset : CharSet) : torna un List de Strings amb totes les l\u00ednies del fitxer writeText( text : String, charset : CharSet) : escriu el string en el fitxer. Si el fitxer ja existia el sobreescriur\u00e0. Opcionalment podem posar el joc de car\u00e0cters que volem utilitzar. Si no el posem utilitzar\u00e0 UTF-8. Observeu que ja dispos\u00e0vem d'un m\u00e8tode que escrivia tot un String anteriorment, per tant no \u00e9s una gran millora, excepte pel fet de poder especificar el joc de car\u00e0cters. A\u00e7\u00f2 s\u00ed que \u00e9s de gran comoditat. appendText( text : String, charset : CharSet) : el mateix que l'anterior, per\u00f2 afegint al final. Com a exemple anem a veure Exemple_2_21.kt. Copieu el seg\u00fcent com Exemple_2_21_bis.kt : package exemples import java.io.File fun main(){ val tot = File(\"f1.txt\").readText() for(c in tot){ println(c) } } I com a exemple d'escriptura, l'adaptaci\u00f3 de Exemple_2_31.kt. Copieu el seg\u00fcent com Exemple_2_31_bis.kt : package exemples import java.io.File fun main() { val text = \"Contingut per al fitxer. Ara ja sense por a car\u00e0cters especials: \u00e7, \u00e0, \u00fa, ...\" File(\"f5.txt\").writeText(text) } I com a exemple de copiar un fitxer en un altre, fins i tot canviant el joc de car\u00e0cters, farem una altra versi\u00f3 del Exemple_2_61.kt. Copieu el seg\u00fcent com Exemple_2_61_bis.kt : package exemples import java.io.File fun main() { File(\"f5_2.txt\").writeText(File(\"f5.txt\").readText(), Charsets.ISO_8859_1) } M\u00e8todes de conversi\u00f3 En ocasions \u00e9s possible que no tinguem un m\u00e8tode directament en File que ens vinga b\u00e9. Un exemple s\u00f3n els m\u00e8todes print (print, println, printf). Aleshores, senzillament a partir del File la classe que ens convinga de la jerarquia de InputStream/OutputStream o Reader/Writer. S\u00f3n m\u00e8todes que ens tornen la classe desitjada: inputStream() : construeix in un InputStream que apunta al File, i el torna inputStream() : el mateix amb un OutputStream reader( charset : Charset) : el mateix amb un Reader, tenint la possibilitat d'especificar el joc de car\u00e0cters (si no s'especifica ser\u00e0 UTF-8) writer( charset : Charset) : el mateix amb un Writer bufferedReader( charset : Charset) : el mateix amb un BufferedReader printWriter( charset : Charset) : el mateix amb un Writer Per exemple, el que hem comentat m\u00e9s amunt: si volem els m\u00e8todes print, senzillament obtenim un PrintWriter a partir del File. D'aquesta manera, el Exemple_2_41.kt ens quedaria d'una altra manera per a obtenir el PrintWriter que vol\u00edem. Copieu el seg\u00fcent com Exemple_2_41_bis.kt : package exemples import java.io.File fun main() { val f_out = File(\"f6.txt\").printWriter() val a = 5.25.toFloat() val b = \"Hola.\" f_out.print(b) f_out.println(\"Qu\u00e8 tal?\") f_out.println(a + 3) f_out.printf(\"El n\u00famero %d en hexadecimal \u00e9s %x\", 27, 27) f_out.close(); } Altres m\u00e8todes Hi ha altres m\u00e8todes que poden ser molt \u00fatils. Per exemple aquell que copia directament un fitxer, o tot un directori recursivament, o que esborra recursivament, ... copyTo( dest\u00ed : File, sobre_escriure : Boolean, buffer : Int) : copia en el fitxer de dest\u00ed. Per defecte no sobreescriur\u00e0, a no ser que posem true en el segon par\u00e0mentre. El tercer par\u00e0metre \u00e9s per a marcar la grand\u00e0ria del buffer de dades per a fer la c\u00f2pia. copyRecursively( dest\u00ed : File, sobre_escriure : Boolean) : copia recursivament el File i tots els seus descendents en el File de dest\u00ed. Per defecte no sobreescriur\u00e0, a menys que posem true en el segon par\u00e0mentre. Opcionalment es pot posar un tercer par\u00e0metre per al tractament dels possibles errors deleteRecursively(): esborra el file i tots els seus possibles descendents Tamb\u00e9 hi ha altres m\u00e8todes, com per exemple per a comprovar si el nom del File t\u00e9 extensi\u00f3, o si comen\u00e7a o finalitza igual que un altre, o per a normalitzar la ruta (llevar possibles redund\u00e0ncies), i altre m\u00e9s. Es poden consultar totes les extensions que proporciona Kotline a la classe File en: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/ Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4 - Simplificaci\u00f3 en Kotlin"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/exercicis/","text":"Exercicis Exercici 2_1 Aquest primer exercicis \u00e9s per a tractament de bytes, ja que es tractar\u00e0 de modificar una imatge. Per a poder provar-lo podeu utilitzar la imatge Penyagolosa.bmp que se us proporciona en l'aula virtual i l'heu de copiar al directori arrel del projecte Tema2 per a un funcionament m\u00e9s c\u00f2mode. No es pret\u00e9n construir un editor d'imatges. Tan sols pretenem agafar la informaci\u00f3 del fitxer byte a byte, realitzar alguna transformaci\u00f3 en els bytes i guardar-la en un altre fitxer. El format d'un fitxer bmp , aproximadament \u00e9s el seg\u00fcent: En els 54 primers bytes es guarda informaci\u00f3 diversa, com la grand\u00e0ria de la imatge, paleta de colors, ... A partir d'ah\u00ed es guarda cada punt de la imatge com 3 bytes , un per al roig (R), un per al verd (G) i i un per al blau (B), anant d'esquerra a dreta i de dalt a baix. Copia't i modifica la classe FitxerImatge en el paquet exercicis , creant els m\u00e8todes oportuns seguint aquestes pautes: El constructor FitxerImatge(File fEnt) ha d'inicialitzar la propietat f ( File ) si i nom\u00e9s si existeix el fitxer i l'extensi\u00f3 del fitxer \u00e9s .bmp (ho controlarem senzillament perqu\u00e8 el nom del fitxer acaba aix\u00ed). En cas contrari, traure els missatges d'error oportuns per l'eixida est\u00e0ndar. Els m\u00e8todes de transformaci\u00f3 ( transformaNegatiu , transformaObscur i el voluntari transformaBlancNegre ) han de crear un nou fitxer que contindr\u00e0 la imatge transformada com veurem m\u00e9s avant. El nom del nou fitxer s'ha de formar a partir del nom del fitxer d'entrada, el que hem guardat en el constructor. Ser\u00e0 sempre posant abans del .bmp un gui\u00f3 baix i un identificatiu de la transformaci\u00f3 realitzada: _n per al negatiu, _o per a l'obscur i _bn per al blanc i negre (part volunt\u00e0ria). \u00c9s a dir, si el fitxer d'entrada f\u00f3ra imatge1.bmp , el d'eixida haur\u00e0 de ser: imatge1_n.bmp per al m\u00e8tode transformaNegatiu imatge1_o.bmp per al m\u00e8tode transformaObscur imatge1_bn.bmp per al m\u00e8tode voluntari transformaBlancNegre **** En cada transformaci\u00f3, els primers 54 bytes s'han de copiar sense modificar: s'han d'escriure en el fitxer de dest\u00ed tal i com s'han llegit del fitxer d'entrada A partir del 54, cada vegada que es llegir\u00e0 un byte, s'haur\u00e0 de transformar abans d'escriure'l en el dest\u00ed. La transformaci\u00f3 \u00e9s d'aquesta manera: Per al negatiu ( transformaNegatiu ), cada byte de color (RGB) de cada punt, s'ha de transformar en el complementari. Com estem parlant de bytes per\u00f2 que en llegir els guardem en enters, senzillament ser\u00e0 calcular 255 - b (si b \u00e9s el byte llegit). Per a l' obscur ( transformaObscur ), cada byte de color (RGB) de cada punt, s'ha de baixar d'intensitat a la meitat. Senzillament ser\u00e0 calcular b / 2 (si b \u00e9s el byte llegit). Per al blanc i negre ( transformaBlancNegre ), que \u00e9s el voluntari, hem de donar el mateix valor per al roig, el blau i el verd (RGB) de cada punt, i aix\u00ed aconseguirem un gris d'intensitat adequada. Una bona manera ser\u00e0 llegir els tres bytes de cada punt ( no s'aconsella utilitzar una lectura amb un array de 3 posicions ; millor fer tres lectures guardades en tres variables diferents), calcular la mitjana d'aquestos 3 valors, i escriure el resultat 3 vegades en el fitxer de dest\u00ed. En cap dels casos anteriors es recomana la lectura dels bytes en un ByteArray, perqu\u00e8 podeu tenir resultats imprevisibles a causa de la interpretaci\u00f3 num\u00e8rica (i per tant amb signe, cosa que en aquest cas no t\u00e9 sentit, ja que han s\u00f3n n\u00fameros del 0 al 255). Es recomana vivament llegir byte a byte . A mode orientatiu del que es vol fer, us adjunte la classe FitxerImatge a la qual heu de modificar el constructor i els tres m\u00e8todes de transformaci\u00f3 (l'\u00faltim \u00e9s voluntari). Recordeu que ha d'anar al paquet exercicis .**** package exercicis import java.io.File class FitxerImatge(fEnt: File) { var f: File = File(\"\") // No modifiqueu aquesta l\u00ednia. El seu valor s'ha de modificar en el constructor init { // Constructor // Control d'exist\u00e8ncia del fitxer i control de l'extensi\u00f3 .bmp (traure missatges d'error) // En cas que tot siga correcte, inicialitzar f amb fEnt } fun transformaNegatiu() { // Transformar a negatiiu i guardar en _n.bmp } fun transformaObscur() { // Transformar a una imatge m\u00e9s fosca i guardar en _o.bmp } /* Partvolunt\u00e0ria fun transformaBlancNegre() { // Transformar a una imatge en blanc i negre i guardar en _bn.bmp } */ } Aquest seria un exemple de programa principal, que podeu utilitzar si voleu. Recordeu que ha d'anar al paquet exercicis i li podeu donar el nom Exercici_2_1.kt . package exercicis import java.io.File fun main(args: Array<String>){ val f = File(\"Penyagolosa.bmp\") val fi = FitxerImatge(f) fi.transformaNegatiu() fi.transformaObscur() //voluntari //fi.transformaBlancNegre() } Per a la imatge que se us proporciona (i que est\u00e0 en la construcci\u00f3 del File del programa principal), que \u00e9s la de l'esquerra, haurien d'eixir les de la dreta: Imatge inicial negatiu obscur blanc i negre (voluntari) Penyagolosa.bmp Penyagolosa_n.bmp Penyagolosa_o.bmp Penyagolosa_bn.bmp Exercici 2_2 Aquest programa ser\u00e0 el primer que utilitzar\u00e0 components gr\u00e0fics. Per a entendre els components gr\u00e0fics de la llibreria Swing i els contenidors de la llibreria Awt , que s\u00f3n els que utilitzarem, us aconselle que us mireu l'annex Gr\u00e0fics en Java: llibreries AWT i SWING ****que teniu en la secci\u00f3 d'annexos, al final del curs de Moodle. De tota manera, us proporcione \"l'esquelet\" del programa, i nom\u00e9s us demane que feu les sent\u00e8ncies de quan s'apreten els botons d'obrir i de guardar. Anem a fer un senzill editor de text amb el seg\u00fcent aspecte: En el JTextField de dalt posarem el nom (i ruta) del fitxer. Quan apretem al bot\u00f3 Obrir ha de bolcar el contingut del fitxer al JTextArea (controlant pr\u00e8viament que existeix el fitxer). Quan apretem a Guardar , ha de bolcar el contingut del JTextArea en el fitxer (el nom del qual tenim en el JTextField ).**** L'esquelet del programa \u00e9s el que trobareu a continuaci\u00f3. He utilitzat la filosofia de l'annex, que consisteix a tenir al final de tot el programa principal (el main) que invoca amb posterioritat ( invokeLater *) una funci\u00f3 que crea l'objecte de la classe que hereta de *JFrame , que \u00e9s realment la finestra, i la fa visible. Una vegada copiat en el paquet exercicis del projecte Tema2 per exemple amb el nom Exercici_2_ 2.kt , nom\u00e9s heu de completar el que teniu al final de tot d'aquesta classe on estan els comentaris, \u00e9s a dir els m\u00e8todes addActionListener dels botons obrir i guardar package exercicis import javax.swing.* import java.awt.* class Exercici_2_2_Pantalla : JFrame() { val et_f = JLabel(\"Fitxer:\") val fitxer = JTextField(25) val obrir = JButton(\"Obrir\") val guardar = JButton(\"Guardar\") val et_a = JLabel(\"Contingut:\") val area = JTextArea(10, 50) val scrollPane = JScrollPane(area) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setLayout(GridLayout(2, 1)) setTitle(\"Editor de text\") val panell1 = JPanel(GridLayout(0, 1)) val panell1_1 = JPanel(FlowLayout()) panell1.add(panell1_1) panell1_1.add(et_f) panell1_1.add(fitxer) val panell1_2 = JPanel(FlowLayout()) panell1.add(panell1_2) panell1_2.add(obrir) panell1_2.add(guardar) val panell2 = JPanel(GridLayout(0, 1)) panell2.add(scrollPane) area.setEditable(true) add(panell1) add(panell2) pack() obrir.addActionListener { // Instruccions per a bolcar el contingut del fitxer en el JTextArea } guardar.addActionListener { // Instruccions per a guardar el contingut del JTextArea al fitxer. } } } private fun crearMostrarFinestra() { val frame = Exercici_2_2_Pantalla() frame.isVisible = true } fun main(args: Array<String>) { EventQueue.invokeLater(::crearMostrarFinestra) } Exercici 2_3. Voluntari Com a exercici voluntari us propose una altra versi\u00f3 del Editor de Text de l'anterior exercici. Ara ser\u00e0 \u00fanicament un JTextArea, i les opcions les tindrem en men\u00fa. Utilitzeu el component JFileChooser per a buscar fitxers i per a guardar-los que ens proporciona Swing . Ja teniu implementada l'opci\u00f3 d'eixir. Si teniu temps i ganes, afegiu un component baix de tot per a triar la codificaci\u00f3 entre UTF-8 i ISO-8859-15 Aquest seria l'esquelet del programa principal i la classe que implementa JFrame. El podeu guardar per exemple en Exercici_2_3.kt : package exercicis import javax.swing.* import java.awt.* import java.io.File class Exercici_2_3 : JFrame() { val area = JTextArea() val scrollPane = JScrollPane(area) val menu_p = JMenuBar() val menu_arxiu = JMenu(\"Arxiu\") val menu_ajuda = JMenu(\"Ajuda\") val obrir = JMenuItem(\"Obrir\") val guardar = JMenuItem(\"Guardar\") val guardarCom = JMenuItem(\"Guardar com ...\") val eixir = JMenuItem(\"Eixir\") val quantA = JMenuItem(\"Quant a Editor\") val fCh = JFileChooser() // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setLayout(BorderLayout()) setTitle(\"Editor de text m\u00e9s avan\u00e7at\") add(scrollPane) area.setEditable(true) setSize(750, 400) setJMenuBar(menu_p) menu_p.add(menu_arxiu) menu_p.add(menu_ajuda) menu_arxiu.add(obrir) menu_arxiu.add(guardar) menu_arxiu.add(guardarCom) menu_arxiu.add(JSeparator()) menu_arxiu.add(eixir) menu_ajuda.add(quantA); obrir.addActionListener { obrir() } guardar.addActionListener { guardar() } guardarCom.addActionListener { guardarCom() } eixir.addActionListener { eixir() } quantA.addActionListener { quantA() } } fun obrir() { // Instruccions per a obrir un fitxer i posar el contingut en el JTextArea } fun guardar() { // Instruccions per a guardar el contingut del JTextArea al fitxer. } fun guardarCom() { // Instruccions per a guardar el contingut del JTextArea al fitxer, amb la possibilitat de canviar el nom } fun eixir() { // Instruccions per a eixir System.exit(0) } fun quantA() { // Instruccions per a mostrar un di\u00e0leg amb la versi\u00f3 (Acerca de...) } } fun main(args: Array<String>) { EventQueue.invokeLater( { Exercici_2_3().isVisible = true }) } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercicis"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/exercicis/#exercicis","text":"","title":"Exercicis"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/exercicis/#exercici-2_1","text":"Aquest primer exercicis \u00e9s per a tractament de bytes, ja que es tractar\u00e0 de modificar una imatge. Per a poder provar-lo podeu utilitzar la imatge Penyagolosa.bmp que se us proporciona en l'aula virtual i l'heu de copiar al directori arrel del projecte Tema2 per a un funcionament m\u00e9s c\u00f2mode. No es pret\u00e9n construir un editor d'imatges. Tan sols pretenem agafar la informaci\u00f3 del fitxer byte a byte, realitzar alguna transformaci\u00f3 en els bytes i guardar-la en un altre fitxer. El format d'un fitxer bmp , aproximadament \u00e9s el seg\u00fcent: En els 54 primers bytes es guarda informaci\u00f3 diversa, com la grand\u00e0ria de la imatge, paleta de colors, ... A partir d'ah\u00ed es guarda cada punt de la imatge com 3 bytes , un per al roig (R), un per al verd (G) i i un per al blau (B), anant d'esquerra a dreta i de dalt a baix. Copia't i modifica la classe FitxerImatge en el paquet exercicis , creant els m\u00e8todes oportuns seguint aquestes pautes: El constructor FitxerImatge(File fEnt) ha d'inicialitzar la propietat f ( File ) si i nom\u00e9s si existeix el fitxer i l'extensi\u00f3 del fitxer \u00e9s .bmp (ho controlarem senzillament perqu\u00e8 el nom del fitxer acaba aix\u00ed). En cas contrari, traure els missatges d'error oportuns per l'eixida est\u00e0ndar. Els m\u00e8todes de transformaci\u00f3 ( transformaNegatiu , transformaObscur i el voluntari transformaBlancNegre ) han de crear un nou fitxer que contindr\u00e0 la imatge transformada com veurem m\u00e9s avant. El nom del nou fitxer s'ha de formar a partir del nom del fitxer d'entrada, el que hem guardat en el constructor. Ser\u00e0 sempre posant abans del .bmp un gui\u00f3 baix i un identificatiu de la transformaci\u00f3 realitzada: _n per al negatiu, _o per a l'obscur i _bn per al blanc i negre (part volunt\u00e0ria). \u00c9s a dir, si el fitxer d'entrada f\u00f3ra imatge1.bmp , el d'eixida haur\u00e0 de ser: imatge1_n.bmp per al m\u00e8tode transformaNegatiu imatge1_o.bmp per al m\u00e8tode transformaObscur imatge1_bn.bmp per al m\u00e8tode voluntari transformaBlancNegre **** En cada transformaci\u00f3, els primers 54 bytes s'han de copiar sense modificar: s'han d'escriure en el fitxer de dest\u00ed tal i com s'han llegit del fitxer d'entrada A partir del 54, cada vegada que es llegir\u00e0 un byte, s'haur\u00e0 de transformar abans d'escriure'l en el dest\u00ed. La transformaci\u00f3 \u00e9s d'aquesta manera: Per al negatiu ( transformaNegatiu ), cada byte de color (RGB) de cada punt, s'ha de transformar en el complementari. Com estem parlant de bytes per\u00f2 que en llegir els guardem en enters, senzillament ser\u00e0 calcular 255 - b (si b \u00e9s el byte llegit). Per a l' obscur ( transformaObscur ), cada byte de color (RGB) de cada punt, s'ha de baixar d'intensitat a la meitat. Senzillament ser\u00e0 calcular b / 2 (si b \u00e9s el byte llegit). Per al blanc i negre ( transformaBlancNegre ), que \u00e9s el voluntari, hem de donar el mateix valor per al roig, el blau i el verd (RGB) de cada punt, i aix\u00ed aconseguirem un gris d'intensitat adequada. Una bona manera ser\u00e0 llegir els tres bytes de cada punt ( no s'aconsella utilitzar una lectura amb un array de 3 posicions ; millor fer tres lectures guardades en tres variables diferents), calcular la mitjana d'aquestos 3 valors, i escriure el resultat 3 vegades en el fitxer de dest\u00ed. En cap dels casos anteriors es recomana la lectura dels bytes en un ByteArray, perqu\u00e8 podeu tenir resultats imprevisibles a causa de la interpretaci\u00f3 num\u00e8rica (i per tant amb signe, cosa que en aquest cas no t\u00e9 sentit, ja que han s\u00f3n n\u00fameros del 0 al 255). Es recomana vivament llegir byte a byte . A mode orientatiu del que es vol fer, us adjunte la classe FitxerImatge a la qual heu de modificar el constructor i els tres m\u00e8todes de transformaci\u00f3 (l'\u00faltim \u00e9s voluntari). Recordeu que ha d'anar al paquet exercicis .**** package exercicis import java.io.File class FitxerImatge(fEnt: File) { var f: File = File(\"\") // No modifiqueu aquesta l\u00ednia. El seu valor s'ha de modificar en el constructor init { // Constructor // Control d'exist\u00e8ncia del fitxer i control de l'extensi\u00f3 .bmp (traure missatges d'error) // En cas que tot siga correcte, inicialitzar f amb fEnt } fun transformaNegatiu() { // Transformar a negatiiu i guardar en _n.bmp } fun transformaObscur() { // Transformar a una imatge m\u00e9s fosca i guardar en _o.bmp } /* Partvolunt\u00e0ria fun transformaBlancNegre() { // Transformar a una imatge en blanc i negre i guardar en _bn.bmp } */ } Aquest seria un exemple de programa principal, que podeu utilitzar si voleu. Recordeu que ha d'anar al paquet exercicis i li podeu donar el nom Exercici_2_1.kt . package exercicis import java.io.File fun main(args: Array<String>){ val f = File(\"Penyagolosa.bmp\") val fi = FitxerImatge(f) fi.transformaNegatiu() fi.transformaObscur() //voluntari //fi.transformaBlancNegre() } Per a la imatge que se us proporciona (i que est\u00e0 en la construcci\u00f3 del File del programa principal), que \u00e9s la de l'esquerra, haurien d'eixir les de la dreta: Imatge inicial negatiu obscur blanc i negre (voluntari) Penyagolosa.bmp Penyagolosa_n.bmp Penyagolosa_o.bmp Penyagolosa_bn.bmp","title":"Exercici 2_1"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/exercicis/#exercici-2_2","text":"Aquest programa ser\u00e0 el primer que utilitzar\u00e0 components gr\u00e0fics. Per a entendre els components gr\u00e0fics de la llibreria Swing i els contenidors de la llibreria Awt , que s\u00f3n els que utilitzarem, us aconselle que us mireu l'annex Gr\u00e0fics en Java: llibreries AWT i SWING ****que teniu en la secci\u00f3 d'annexos, al final del curs de Moodle. De tota manera, us proporcione \"l'esquelet\" del programa, i nom\u00e9s us demane que feu les sent\u00e8ncies de quan s'apreten els botons d'obrir i de guardar. Anem a fer un senzill editor de text amb el seg\u00fcent aspecte: En el JTextField de dalt posarem el nom (i ruta) del fitxer. Quan apretem al bot\u00f3 Obrir ha de bolcar el contingut del fitxer al JTextArea (controlant pr\u00e8viament que existeix el fitxer). Quan apretem a Guardar , ha de bolcar el contingut del JTextArea en el fitxer (el nom del qual tenim en el JTextField ).**** L'esquelet del programa \u00e9s el que trobareu a continuaci\u00f3. He utilitzat la filosofia de l'annex, que consisteix a tenir al final de tot el programa principal (el main) que invoca amb posterioritat ( invokeLater *) una funci\u00f3 que crea l'objecte de la classe que hereta de *JFrame , que \u00e9s realment la finestra, i la fa visible. Una vegada copiat en el paquet exercicis del projecte Tema2 per exemple amb el nom Exercici_2_ 2.kt , nom\u00e9s heu de completar el que teniu al final de tot d'aquesta classe on estan els comentaris, \u00e9s a dir els m\u00e8todes addActionListener dels botons obrir i guardar package exercicis import javax.swing.* import java.awt.* class Exercici_2_2_Pantalla : JFrame() { val et_f = JLabel(\"Fitxer:\") val fitxer = JTextField(25) val obrir = JButton(\"Obrir\") val guardar = JButton(\"Guardar\") val et_a = JLabel(\"Contingut:\") val area = JTextArea(10, 50) val scrollPane = JScrollPane(area) // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setLayout(GridLayout(2, 1)) setTitle(\"Editor de text\") val panell1 = JPanel(GridLayout(0, 1)) val panell1_1 = JPanel(FlowLayout()) panell1.add(panell1_1) panell1_1.add(et_f) panell1_1.add(fitxer) val panell1_2 = JPanel(FlowLayout()) panell1.add(panell1_2) panell1_2.add(obrir) panell1_2.add(guardar) val panell2 = JPanel(GridLayout(0, 1)) panell2.add(scrollPane) area.setEditable(true) add(panell1) add(panell2) pack() obrir.addActionListener { // Instruccions per a bolcar el contingut del fitxer en el JTextArea } guardar.addActionListener { // Instruccions per a guardar el contingut del JTextArea al fitxer. } } } private fun crearMostrarFinestra() { val frame = Exercici_2_2_Pantalla() frame.isVisible = true } fun main(args: Array<String>) { EventQueue.invokeLater(::crearMostrarFinestra) }","title":"Exercici 2_2"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/exercicis/#exercici-2_3-voluntari","text":"Com a exercici voluntari us propose una altra versi\u00f3 del Editor de Text de l'anterior exercici. Ara ser\u00e0 \u00fanicament un JTextArea, i les opcions les tindrem en men\u00fa. Utilitzeu el component JFileChooser per a buscar fitxers i per a guardar-los que ens proporciona Swing . Ja teniu implementada l'opci\u00f3 d'eixir. Si teniu temps i ganes, afegiu un component baix de tot per a triar la codificaci\u00f3 entre UTF-8 i ISO-8859-15 Aquest seria l'esquelet del programa principal i la classe que implementa JFrame. El podeu guardar per exemple en Exercici_2_3.kt : package exercicis import javax.swing.* import java.awt.* import java.io.File class Exercici_2_3 : JFrame() { val area = JTextArea() val scrollPane = JScrollPane(area) val menu_p = JMenuBar() val menu_arxiu = JMenu(\"Arxiu\") val menu_ajuda = JMenu(\"Ajuda\") val obrir = JMenuItem(\"Obrir\") val guardar = JMenuItem(\"Guardar\") val guardarCom = JMenuItem(\"Guardar com ...\") val eixir = JMenuItem(\"Eixir\") val quantA = JMenuItem(\"Quant a Editor\") val fCh = JFileChooser() // en iniciar posem un contenidor per als elements anteriors init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setLayout(BorderLayout()) setTitle(\"Editor de text m\u00e9s avan\u00e7at\") add(scrollPane) area.setEditable(true) setSize(750, 400) setJMenuBar(menu_p) menu_p.add(menu_arxiu) menu_p.add(menu_ajuda) menu_arxiu.add(obrir) menu_arxiu.add(guardar) menu_arxiu.add(guardarCom) menu_arxiu.add(JSeparator()) menu_arxiu.add(eixir) menu_ajuda.add(quantA); obrir.addActionListener { obrir() } guardar.addActionListener { guardar() } guardarCom.addActionListener { guardarCom() } eixir.addActionListener { eixir() } quantA.addActionListener { quantA() } } fun obrir() { // Instruccions per a obrir un fitxer i posar el contingut en el JTextArea } fun guardar() { // Instruccions per a guardar el contingut del JTextArea al fitxer. } fun guardarCom() { // Instruccions per a guardar el contingut del JTextArea al fitxer, amb la possibilitat de canviar el nom } fun eixir() { // Instruccions per a eixir System.exit(0) } fun quantA() { // Instruccions per a mostrar un di\u00e0leg amb la versi\u00f3 (Acerca de...) } } fun main(args: Array<String>) { EventQueue.invokeLater( { Exercici_2_3().isVisible = true }) } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercici 2_3. Voluntari"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/objectius/","text":"Objectius L'objectiu d'aquest tema ser\u00e0 accedir al contingut dels fitxers, b\u00e9 per a llegir \u00fanicament o b\u00e9 per a guardar informaci\u00f3 de forma permanent. Per a a\u00e7\u00f2 en Java disposem de les classes de flux de dades ( streams ). Lamentablement Java disposa d'una quantitat de streams extraordin\u00e0riament gran, cosa que suposa una gran complexitat per al programador (ja que ha de recordar moltes classes). Per contra ofereix una potencialitat molt gran. Donada aquesta varietat de classes i la complexitat inherent, aquest tema comen\u00e7ar\u00e0 el tractament del contingut dels fitxers separant les classes en 2 categories: considerant la informaci\u00f3 com un conjunt de bytes, i considerant- la com un conjunt de car\u00e0cters. Afortunadament Kotlin simplifica molt el tractament, i no caldr\u00e0 utilitzar tantes classes. No obstant aix\u00f2, \u00e9s recomanable saber tota la jerarquia de classes e Java per a poder dominar l'acc\u00e9s a fitxers tamb\u00e9 en Kotlin. El seg\u00fcent tema ser\u00e0 una continuaci\u00f3 d'aquest, veient formats especials de fitxers i tamb\u00e9 diferents maneres d'accedir. Nota Per als exemples i exercicis d'aquest tema, heu de crear un projecte nou, Tema2 . Haureu de crear 2 paquets, exemples i exercicis , de forma similar a com hav\u00edem fet en el Tema 1. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"},{"location":"AD_T2_Gesti_del_contingut_de_fitxers/objectius/#objectius","text":"L'objectiu d'aquest tema ser\u00e0 accedir al contingut dels fitxers, b\u00e9 per a llegir \u00fanicament o b\u00e9 per a guardar informaci\u00f3 de forma permanent. Per a a\u00e7\u00f2 en Java disposem de les classes de flux de dades ( streams ). Lamentablement Java disposa d'una quantitat de streams extraordin\u00e0riament gran, cosa que suposa una gran complexitat per al programador (ja que ha de recordar moltes classes). Per contra ofereix una potencialitat molt gran. Donada aquesta varietat de classes i la complexitat inherent, aquest tema comen\u00e7ar\u00e0 el tractament del contingut dels fitxers separant les classes en 2 categories: considerant la informaci\u00f3 com un conjunt de bytes, i considerant- la com un conjunt de car\u00e0cters. Afortunadament Kotlin simplifica molt el tractament, i no caldr\u00e0 utilitzar tantes classes. No obstant aix\u00f2, \u00e9s recomanable saber tota la jerarquia de classes e Java per a poder dominar l'acc\u00e9s a fitxers tamb\u00e9 en Kotlin. El seg\u00fcent tema ser\u00e0 una continuaci\u00f3 d'aquest, veient formats especials de fitxers i tamb\u00e9 diferents maneres d'accedir. Nota Per als exemples i exercicis d'aquest tema, heu de crear un projecte nou, Tema2 . Haureu de crear 2 paquets, exemples i exercicis , de forma similar a com hav\u00edem fet en el Tema 1. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"}]}